<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GAMES101 - 实验环境搭建</title>
    <link href="/2020/12/05/GAMES101-LAB/"/>
    <url>/2020/12/05/GAMES101-LAB/</url>
    
    <content type="html"><![CDATA[<h3 id="GAMES101-Vscode可行配置"><a href="#GAMES101-Vscode可行配置" class="headerlink" title="GAMES101 Vscode可行配置"></a>GAMES101 Vscode可行配置</h3><p>环境：Vscode + CMakeTools + CppTools + Mingw64</p><p>Vscode中C++引入第三方库的方式大致有以下三种：</p><ol><li>对于非Cmake项目，利用CppTools（Miscrosoft官方为Vscode提供的编译和调试插件）的IntelliSense功能，通过设置<code>c_cpp_properties.json</code>中的includePath项引入对应库的<code>/include</code>目录。</li><li>对于Cmake项目，利用CMakeTools （Miscrosoft官方为Vscode提供的Cmake插件）一键基于<code>CMakeList.txt</code>生成<code>/build</code>目录，在通过内置终端make并运行。</li><li><p>对于Cmake项目，同时使用CppTools与CMakeTools ，高度自动化的预设置支持一键build和一键debug，在配置合理的情况下这种方式是最高效的。麻烦点在于需要对<code>setting.json</code>，<code>c_cpp_properties.json</code>，<code>task.json</code>，<code>launch.json</code>进行额外配置。假设使用windows下以mingw64为编译器，具体改动如下。</p><ul><li><p><code>setting.json</code>。在工作区配置中将<em>C_Cpp.default.configurationProvider</em>设置为<em>ms-vscode.cmake-tools</em>，表示通过CMakeTools 引入外部链接而不是内置的includePath。</p></li><li><p><code>c_cpp_properties.json</code>。如果在<code>setting.json</code>中已配置或配置失效，可以添加<em>configurationProvider</em>设置为<em>ms-vscode.cmake-tool</em>从而实现同样的引入效果，两者不冲突。</p></li><li><p><code>task.json</code>。由于CMakeTools 在<code>CMakeList.txt</code>保持的时候就完成了build，因此只需提供make的任务指令即可，具体指令根据环境变量的设置而变，一般为make或mingw32-make，json配置如下</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// tasks下添加</span>&#123;            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,            <span class="hljs-attr">&quot;options&quot;</span>: &#123;                <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span>            &#125;,            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;mingw32-make -j4&quot;</span>, &#125;</code></pre></div></li><li><p><code>launch.json</code>。注意指定正确的miDebuggerPath和program，并加载<code>task.json</code>中新添加的make为前置任务，json配置如下（Assignments2为例）</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;configurations&quot;</span>: [        &#123;            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;debug&quot;</span>,            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\build\\Rasterizer.exe&quot;</span>,            <span class="hljs-attr">&quot;args&quot;</span>: [],            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,            <span class="hljs-attr">&quot;environment&quot;</span>: [],            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;D:\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [                &#123;                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span>                &#125;            ],            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>        &#125;    ]</code></pre></div></li></ul></li></ol><h3 id="其他坑"><a href="#其他坑" class="headerlink" title="其他坑"></a>其他坑</h3><ol><li>eigen和opencv自带include文件无法被正确引入时，需要自己用Cmake进行本地构建和编译，这里的坑搜一下网上的文章基本能解决。</li><li>在用mingw本地编译opencv时需要使用mingw64-posix离线版，online版的选了posix还不行。</li><li>CMakeList.txt找不着包，是环境变量没有被正确配置。所幸GAMES101的助教提供了写好的CMakeList作为参照，把拥有<code>xxxconfig.cmake</code>的目录添加到对应的环境变量即可（例如设置OpenCv DIR目录为包含<code>opencvconfig.cmake</code>的路径），不必绕进cmake的一堆坑。</li></ol>]]></content>
    
    
    <categories>
      
      <category>graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer-graphics</tag>
      
      <tag>fundamentals</tag>
      
      <tag>env-config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES101 - 现代计算机图形学入门</title>
    <link href="/2020/11/27/GAMES101/"/>
    <url>/2020/11/27/GAMES101/</url>
    
    <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>GAMES101是GAMES (<em>Graphics And Mixed Environment Seminar</em>）系列公益课程的第一部，由UCSB的助理教授闫令琪授课，该课程专注于图形学基本原理的分析与解释。本文内容为Transformation, Rasterization笔记。</p><!-- toc --><span id="more"></span><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p><img src="/2020/11/27/GAMES101/image-20201127165907506.png" alt></p><h4 id="Covered-Topics"><a href="#Covered-Topics" class="headerlink" title="Covered Topics"></a>Covered Topics</h4><ul><li>Rasterization</li><li>Curves and Meshes</li><li>Ray Tracing</li><li>Animation / Simulation</li></ul><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote><p>Fundamentals Of Computer Graphics 3th Edition</p></blockquote><hr><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>图形学中 Transformation 的核心问题是找到一个变换矩阵 $ M $ ，使得空间中任意一个Vetcor可以利用$M$ 进行缩放、反转、切边、旋转和平移。其中平移变换的引入需要利用齐次坐标表示$M$的仿射变换，因此，在三维向量空间中$M$应为一个4x4的矩阵。 Transformation的所有内容将基于齐次坐标构建的变换矩阵。Transformation中一个重要假设是任何复合变换都可以依次分解为各个独立变换，复合变换中，优先平移，其次线性变换。</p><h4 id="点和向量的表示"><a href="#点和向量的表示" class="headerlink" title="点和向量的表示"></a>点和向量的表示</h4><p><strong>Point</strong> = $(x,y,z,1)^\intercal$ or $(wx,wy,wz,w)^\intercal$ subject to $w&gt;0$</p><p><strong>Vector </strong>= $(x,y,z,0)^\intercal$（$w=0$实际上保护了Vector的平移不变性）</p><h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><script type="math/tex; mode=display">M =  \left[ \begin{matrix}   S_x & 0 & 0 & 0\\   0 & S_y & 0 & 0\\  0 & 0 & S_z & 0\\0 & 0 & 0 & 1\end{matrix}  \right]</script><h4 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h4><ul><li>以x-axis为例， y-axis, z-axis 同理。</li></ul><script type="math/tex; mode=display">M =  \left[ \begin{matrix}   -1 & 0 & 0 & 0\\   0 & 1 & 0 & 0\\  0 & 0 & 1 & 0\\0 & 0 & 0 & 1\end{matrix}  \right]</script><h4 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h4><ul><li>Default<ul><li>(0, 0, 0)为原圆心</li><li>逆时针</li></ul></li><li>由于Rotation的输入为角度$\theta$，其变换矩阵的逆刚好等于转置，满足正交矩阵性质。该性质简化了视图变换$M$的推导。</li></ul><p>以沿x-axis旋转为例， y-axis, z-axis 同理。</p><script type="math/tex; mode=display">\left[ \begin{matrix}   1 & 0 & 0 & 0\\   0 & \cos\theta & -\sin\theta & 0\\  0 & \sin\theta & \cos\theta & 0\\0 & 0 & 0 & 1\end{matrix}  \right]</script><ul><li><p>Rotation也满足Transformation复合叠加的假设</p><script type="math/tex; mode=display">R_{xyz}(\alpha,\beta,\gamma)=R_x(\alpha)R_y(\beta)R_z(\gamma)</script></li><li><p>Rodrigues’ rotation formula</p><p>罗德里格旋转公式是表达三维空间的另一种形式，其输入不再是三个轴上的旋转角度，而是选择一个单位向量 $n$ 作为旋转轴，以及 $\alpha$ 作为绕该单位向量旋转角度，公式如下：</p><p><img src="/2020/11/27/GAMES101/image-20201127194327234.png" alt="image-20201127194327234"></p></li></ul><h4 id="View-Transform"><a href="#View-Transform" class="headerlink" title="View Transform"></a>View Transform</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>一个3D空间向2D投影的过程包括三步：</p><ol><li>model transform</li><li>view transform</li><li>projection transform</li></ol><p>对于View Transform， 我们定义空间中的一个相机为 $(e,g,t)$，分别代表相机的Position, Look-at Direction, Up Direction（该向量定义正交于$g$）。View Transform的目标是找到一个变换矩阵<script type="math/tex">M_{view} = R_{view}T_{view}</script>，使得相机的Position回到原点，Look-At Direction面向<script type="math/tex">-z</script>， Up Direction面向<script type="math/tex">y</script></p><p><img src="/2020/11/27/GAMES101/image-20201127201909367.png" alt="image-20201127201909367"></p><p>这里运用了旋转矩阵作为正交矩阵的性质，矩阵的逆等于矩阵的转置，更加直观。</p><h4 id="Projection-Transform"><a href="#Projection-Transform" class="headerlink" title="Projection Transform"></a>Projection Transform</h4><ul><li>Orthographic Transform</li><li>Perspective Transform</li></ul><p><img src="/2020/11/27/GAMES101/image-20201127202458361.png" alt="image-20201127202458361"></p><p><img src="/2020/11/27/GAMES101/image-20201127202533997.png" alt="image-20201127202533997"></p><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>投影变换是将3D空间信息转换为2D信息，而投影分为正交投影和透视投影，两者区别就是相机与近视屏幕的距离是否为无限。实现投影变换一个简单的思路就是去轴，例如通过移除Z轴我们就得到了X-Y平面的投影信息。但是显然这种方法是有缺陷的，大多时候我们期望投影变换后不会损失三维空间的信息。换言之，投影变换需要保留近视平面到远视平面形成的整个可视空间的信息。</p><p>因此，投影变换的目的是<strong>可视空间投影到一个以原点为中心的[1,1,1]的正则空间(canonical cube)</strong></p><h5 id="Orthographic-Transform"><a href="#Orthographic-Transform" class="headerlink" title="Orthographic Transform"></a>Orthographic Transform</h5><p><img src="/2020/11/27/GAMES101/image-20201127203648697.png" alt="image-20201127203648697"></p><h5 id="Perspective-Transform"><a href="#Perspective-Transform" class="headerlink" title="Perspective Transform"></a>Perspective Transform</h5><p>透视变换略微比正交变换复杂，因为透视相机的可视空间是一个截锥体（Frustum），这里闫老师给了一种很好理解的方式，我们先把Frustum转换为Cubiod，再使用Orthographic Transform的转换矩阵即可。而Frustum转换为Cubiod的推导也很有意思。</p><p>我们希望Frustum转换为Cubiod，首先需要使近远视平面大小一致，由于相机更接近于近视平面所以我们希望远视平面变小，就像四个手指头挤压远视平面一样。因此有如下条件</p><ol><li>相机已完成视图变换</li><li>近视平面上的点恒定不变</li><li>远视平面上点的Z轴信息恒定不变</li></ol><p>设近视平面上的点为$(x’,y’,z’)$，远视平面上的点$(x,y,z)$，分别以$-x$和$-y$的角度去观测Frustum，根据相似三角形的信息，我们可以得到</p><p><img src="/2020/11/27/GAMES101/image-20201127210322765.png" alt="image-20201127210322765"></p><p><img src="/2020/11/27/GAMES101/image-20201127210332807.png" alt="image-20201127210332807"></p><p>对于远视平面上的任意点，在齐次坐标下我们可以表示为</p><p><img src="/2020/11/27/GAMES101/image-20201127210436925.png" alt="image-20201127210436925"></p><p>可以腿短$M_{persp\rightarrow ortho}$满足</p><p><img src="/2020/11/27/GAMES101/image-20201127210644723.png" alt="image-20201127210644723"></p><p><img src="/2020/11/27/GAMES101/image-20201127210655158.png" alt="image-20201127210655158"></p><p>现在我们只有第三行的四个信息未知，再利用假设2可以得到</p><p><img src="/2020/11/27/GAMES101/image-20201127211002360.png" alt="image-20201127211002360"></p><p><img src="/2020/11/27/GAMES101/image-20201127211010418.png" alt="image-20201127211010418"></p><p>假设3可以得到</p><p><img src="/2020/11/27/GAMES101/image-20201127211022450.png" alt="image-20201127211022450"></p><p>最后得出A,B</p><p><img src="/2020/11/27/GAMES101/image-20201127211039149.png" alt="image-20201127211039149"></p><p>本节的思考题是在可视空间中非视平面上的点的Z轴的值是如何变化的，直观的感受我们知道Z轴的值肯定是变大的（因为远小），也可以利用矩阵计算验证，如下。</p><p><img src="/2020/11/27/GAMES101/44B0C4A76D6E4E248776D089B16AA050.png" alt="img" style="zoom:50%;"></p><hr><h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><p>光栅化 (Rasterization) 是原德语的音译，实际做的就是把正则观测矩阵的信息投在屏幕上。</p><ul><li>Field-of-View (FOV) 相机到近平面中点的连线与其到近平面边的连线的夹角</li><li>Aspect Ratio 横纵比 <script type="math/tex">\frac WH</script></li></ul><p>本章节定义屏幕像素是一个由RGB三色空间组成的纯色块，采用XY平面坐标系。Raster要做的是把连续的图像信息投影到离散的像素平面上，首先利用<script type="math/tex">M_{viewport}</script>将观测平面大小拉伸至屏幕平面大小，然后对观测空间中的三角形做离散采样。第二步具体表现为，根据每个三角形的顶点坐标定义一个操作空间，之后对操作空间每一个像素点经过<script type="math/tex">inside(tri,x,y)</script>函数判断其是否处在三角形内（叉乘的性质），从而判断某一像素是否需要被投影（渲染？）</p><p>这里有几个假设需要提及</p><ol><li><p>选择三角形的原因</p><p>a. 最简单的多边形</p><p>b. 三角形的三个顶点一定在一个平面，不存在凹运算</p><p>c. 与b相似，由于三角形不存在凹运算因此内外的定义也很直接</p></li><li><p>假设像素是投影的最小单元，每个像素仅有一个采样点为其中点。</p></li><li>采样方式不一定是选取操作空间，也可以选取一个顶点作为根进行遍历。</li></ol><p><img src="/2020/11/27/GAMES101/image-20201128213237552.png" alt="image-20201128213237552"></p><h4 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h4><p>既然是采样，肯定就要涉及奈奎斯特-香农采样定理，也肯定要涉及Aliasing（信号中译为混叠，图形学译为锯齿），为了实现Antialiasing，就需要补充一些信号与系统在图形学中的解释。</p><p><img src="/2020/11/27/GAMES101/image-20201128214234227.png" alt="image-20201128214234227" style="zoom:50%;"></p><p>我们假设图像信号是连续的波形函数，在频域中我们可以通过傅里叶级数将其分解多个不同频率的简谐函数。我们想象计算机以特定频率<script type="math/tex">F</script>进行采样，如果其中的某一条简谐信号的频率<script type="math/tex">F'</script>远大于<script type="math/tex">F</script>，这个频率下的信息就被错误采样了。这就导致了Aliasing。</p><p><img src="/2020/11/27/GAMES101/image-20201128215717490.png" alt="image-20201128215717490" style="zoom:50%;"></p><p>显然我们不能对单一的简谐信号操作，想要使特定频率的不被采用只需要对原信号进行滤波即可，而对于图像想好的滤波，直观上有一些比较有趣的结果。</p><p><img src="/2020/11/27/GAMES101/image-20201128215938138.png" alt="image-20201128215938138" style="zoom:67%;"></p><p><img src="/2020/11/27/GAMES101/image-20201128215958829.png" alt="image-20201128215958829" style="zoom:67%;"></p><p><img src="/2020/11/27/GAMES101/image-20201128220011302.png" alt="image-20201128220011302" style="zoom:67%;"></p><p>由图可知，高频保存了边界信息，而低频保存了变化幅度较低的色块信息。解释一下频域图里的横竖亮线，这是由于图像时域信号假设中是在XY两个方向上无穷的，亮线的部分实际就是边界的突变。（这里提一下，我之前看到对抗攻击的防御中，就有通过频域识别扰动的方法，研究结果表明对抗生成的样本在频域图下不止一个高亮点，而是多个高亮点等距离分部）我们用盒形的卷积滤波器的到的图像如下。</p><p><img src="/2020/11/27/GAMES101/image-20201128220805165.png" alt="image-20201128220805165" style="zoom:67%;"></p><p>以特定频率采样，这个过程实际上就是把图像信号的原始信息进行复制粘贴。（卷积的性质）<img src="/2020/11/27/GAMES101/image-20201128221214621.png" alt="image-20201128221214621"></p><p>于是图像学的Aliasing和信号系统的联系了起来</p><p><img src="/2020/11/27/GAMES101/image-20201128221416006.png" alt="image-20201128221416006" style="zoom:67%;"></p><p>解决方法也很直接</p><ol><li>提高采样频率</li><li>整个低通滤波器</li></ol><p>然而在每个像素不止一个采样点的假设下，就能有一种更优的方案。根据每个像素中三角形内的采样点占总采样点数目的比例，我们可以动态的决定每一个像素要如何滤波，而不是对整体运用一个滤波器。这样相当于用更多的采样点换取更少的计算量。这也是MSAA的核心思路。</p><h4 id="Antialiasing-Today"><a href="#Antialiasing-Today" class="headerlink" title="Antialiasing Today"></a>Antialiasing Today</h4><p><img src="/2020/11/27/GAMES101/image-20201128222401408.png" alt="image-20201128222401408"></p><p>这里简要介绍一下，FXAA就是拓展了MSAA的假设，即每个像素内的采样点分布不是均匀的，而会根据光栅化类型利用一些算法智能分布。TAA则是通过前一帧或前几帧的采样点设置信息来动态的设置本该帧某些特定的采样点，相当于是将计算在时间上打乱了。</p>]]></content>
    
    
    <categories>
      
      <category>graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>graphics</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameJam - LudumDare46</title>
    <link href="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/"/>
    <url>/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本着「 Learning by Doing 」的想法，刚入坑两周的我决定参加LudumDare46去体验完整的小游戏开发过程，由于并没有学过原型实现工具，因此工程上就采用速成的U3D，美术素材部分基于现有素材的二次修改，其余用Aseprite绘制，音乐选自opengameart.org的Dont touch it，个人觉得不错就使用了。</p><p><img src="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/find.png" alt></p><span id="more"></span><h3 id="Day1：-构思想法，实现原型"><a href="#Day1：-构思想法，实现原型" class="headerlink" title="Day1： 构思想法，实现原型"></a>Day1： 构思想法，实现原型</h3><p>第一天公布早上八点半起床，嗦碗粉到九点Twitter确认主题 <em>Keep it alive</em>。当时U3D技术水平只做过一些2D Platformer的实现，因此我能做的游戏形式并没有多少选择。很快我就决定做2D Platformer了，综合看来这一唯一可行的方案，回到主题 <em>Keep it alive</em>，当时立刻想到了一款忘记名字的游戏Demo，主角的生命进入倒计时，通过击杀敌人可以延续倒计时时长，玩家需要在固定场景内击杀不断涌现的敌人来延续生命（怒火攻心内味）。</p><p>但是这种方案对我来说工作量可能较大，而且这个想法比较容易想到，就没有采用。之后我基本上是围绕 <em>it</em> 去想，代入了很多游戏元素，最后决定让 <em>it</em> = <em>the camera</em>，让玩家需要时刻保持游戏镜头的移动否则镜头会持续缩小，而移动会让镜头逐渐增大。</p><p>镜头大小影响的核心机制肯定是探索和寻找，因此我没有多想就把游戏目标设为「 在一个开放场景下找到这个游戏的作者，然后Beat his ass off 」。</p><p>由于玩家需要持续移动，所以2D Plateformer的移动系统一定要做好，要能够给玩家足够的移动控件，最后我决定参考《蔚蓝》的移动系统，将比较断节奏的爬墙改成了持续蹬墙。</p><p>然后是决定游戏的互动机制，因为Jam作品要求小而精，所以在确定奖惩机制后如何互动的问题也就解决了，传统2D Plateformer里的尖刺、电锯啥的元素肯定都有（我也搞不出新的素材）。最后决定奖惩也围绕着核心机制设计：受伤缩小镜头，使用消耗品药片增大镜头。</p><p>大概下午1点左右就基本确定了核心机制、游戏目标、移动系统和反馈机制，然后…..我就摸鱼去了，摸到3点开始用U3D做原型，晚上11点基本写完，查文档和论坛找解决方案的过程着实痛苦，那天晚上整个人昏昏沉沉的，像条死鱼。</p><p><img src="https://media.giphy.com/media/VdWXU2JnrCstn0oSMs/giphy.gif" alt></p><h3 id="Day2-优化机制，搞定美术"><a href="#Day2-优化机制，搞定美术" class="headerlink" title="Day2: 优化机制，搞定美术"></a>Day2: 优化机制，搞定美术</h3><p>第二天啥时候起的给忘了，总之是摸鱼到了中午才开始做。内容是优化原先设计的机制，主要分两点：一是调整手感，二是精简内容。调整手感本质上就是调整一系列动力参数，什么JumpForce, runSpeed, dashSpeed这些， 整个过程有DL炼丹内味了，总之就是不断的试错调整。精简内容上主要是删除了一些游戏元素，删掉了前一天做的磁力装置，考虑到磁力装置更多要求的玩家在慢节奏下做策略决定，然后确定了游戏元素的范围。</p><p>然后是美术，这一点我不头大，我完全了解自己的上限，绘制简易Item动画和Tilemap就行，人物动作素材必须找，自己画就过于抽象了。</p><p>人物素材就用了一个比较经典的 Virtual Boy 形象，B站不少UP的案例里用的也是这个，然后用Aseprite修改颜色统一素材基调。Item和Map素材比较简单就用Aseprite绘制了（因为Procreate怎么设置笔刷像素点都会扩散）。</p><p><img src="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/asset.png" alt></p><h3 id="Day3：爆肝场景，解决杂项"><a href="#Day3：爆肝场景，解决杂项" class="headerlink" title="Day3：爆肝场景，解决杂项"></a>Day3：爆肝场景，解决杂项</h3><p>这一天基本都在做场景，当时还挺急的，一方面既然寻找是玩家的目标那么场景不能太小，另一方面绘制想metroidvania的大场景我没有经验，最后的场景基本就是一些小谜题放至在大场景框架下的不同地方。</p><p>而且，在做场景期间我突然想到个点子，让玩家有能力与地图中的Item交换位置，这样玩家就有能力自己改变地形。当时没多想就去肝这个功能去了，最后完是完成了，但场景还有大半没做完，所有有些场景做的比较草率。</p><p>然后就是杂项，音乐、UI、发布、托管这些基本都是按照最简单的方式去做的，音乐的话我觉得选的Dont touch it 还是不错的，音效没有找到适合的自己也不敢做就放弃了；UI也是精简为主，一个显示药品余量，一个表示镜头大小。最后就是itch托管和ludumdare发布，当时以为发布的游戏内容可以修改的，就没有挂图片，只提供了个Windows版的，后来发现改不了，有点难受。</p><p><img src="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/start.png" alt></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>以下是我写在KeepTheCamAive的游戏介绍</p><blockquote><p>You going to find the author of this game and beat his ass off(in game!), and always remember Keep the Camera Alive. </p><p>↑↓←→ to move; Z to Dash; X to Throw ; C to Switch; E to Eat</p></blockquote><p>这里有个操作想稍微解释下（当时给朋友玩他就没懂），X会扔出一个小球，小球扔到游戏内某些Item会消失（原本想做一个爆炸的动画，但是忘掉了…），此时玩家就与这个Item联系上了，然后再Switch…..</p><h3 id="经历反思"><a href="#经历反思" class="headerlink" title="经历反思"></a>经历反思</h3><p>整个过程体验其实比较憋屈，主要原因还是自己太菜了，没有能力快速实现自己的想法。而对于Jam而言，我的所有想法都受限于我的技术水平（我不敢跳脱出2D Plateformer），单从技术上去看，也没有用到U3D的一些关键技术URP啊Shader啊，最后有些问题我都没有解决，比如游戏画面的闪白线条，可能是由于素材重叠造成的，但是尝试了一系列解决方案后都无效。还是因为缺乏对图形学基本原理和引擎操作的扎实基础。</p><p>收获仍然是有的，自己也算是经历了一款小游戏从设计到实现到优化到发布的全过程，好歹算是做出了个作品。</p><p>LudumDare主要关注的仍然是创意和游戏音画的综合表现，但好的创意和想法，在这72h里也需要扎实的技术基础去实现，提高技术的深度和广度是提升Jam水平的重要方式。音画技能的基本技能也需要具备，当然更好的方式是合作。</p>]]></content>
    
    
    <categories>
      
      <category>gamejam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>metriodvania</tag>
      
      <tag>game dev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏解构的基本框架</title>
    <link href="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要根据个人的学习情况记录一些游戏分析与解构的常用框架、关注重心和实际方法。仅代表个人观点，可能与他人观点或书本有出入。</p><span id="more"></span><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>这里首先需要明确框架的意义，其主要目的是通过提供偏范式化的思维体系帮助游戏设计师更全面而细致的观察、分析或是构建一款游戏，切勿陷入完全的教条主义，使用时需同时结合思维体系和实践经验对游戏无论是优秀或是缺陷的设计进行更深入的认知。</p><p>常见的游戏分析框架有三种：MDA、FDD和四元法，每种框架都有各自的侧重点。</p><h4 id="MDA"><a href="#MDA" class="headerlink" title="MDA"></a>MDA</h4><p><strong>MDA</strong>即机制（Mechanics）、动态（Dynamics）、美学（Aesthetics），于2004年的游戏学论文《MDA：游戏设计的和研究的形式方法》中正式提出，主要强调设计师应首先关注游戏的美学，其次再处理动态和机制。</p><p>使用MDA框架的重点在于如何认知包含的机制、动态、美学三大元素。它们的标准化定义如下：</p><p><strong>机制</strong>：游戏数据层面的组件、算法和逻辑</p><p><strong>动态</strong>：玩家行为与游戏系统之间的互动反馈</p><p><strong>美学</strong>：玩家交互时产生的体验与情感。</p><p>说简洁点，机制、动态、美学分别代表工程，互动和体验。这里容易产生的一个误区是，美术、音效、音乐等资源更适合归类于动态范畴而否美学，美学的描述对象应是更抽象更主观的玩家体验。</p><p>举一个实际的案例，奥日与萤火意志，机制描述内容包括精灵碎片系统、精灵之光系统、技能系统、移动系统、场景构建、BOSS战设计、追逐战设计等；动态可以描述为“通过精灵之光解锁新技能”、“通过猛击反弹敌人攻击”、“利用精灵冲击探索地图收集碎片”等；美学的描述可能会更加主观：“通过孤立无援的情况下与豪尔的战斗营造紧张感与沮丧感”、“通过收集种子修缮家园让玩家感到自豪与成就”、“通过连续无落地的猛击关卡使玩家保持持续的专注”等。</p><p>大致理解上述描述后再思考MDA关系图，如下所示。</p><p><img src="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/1.jpg" alt="蜂蜜浏览器_33738CF9C90006C121C9BEC394CBBEC1"></p><p>我们发现MDA实际上是鼓励设计师从玩家的角度出发，将玩家的体验向底层描述归纳为动态和机制，在从机制出发，反向递推出设计师想要构建的体验。这是很常见也是习惯性的设计思路，也抓住了游戏的核心目的：创造玩家的体验。但是MDA作为一个早期的分析思路也存在一些问题。</p><p><strong>首先，MDA的基本假设之一从机制推导到玩家体验，这一过程存在很大的混沌性。</strong>这个问题的本质源于以客观理论描述主观体验的难度，以客述主的困难也是客观存在的，但从我找到的资料中，MDA并给出一些指导性方案帮助设计师推理。</p><p><strong>其次，MDA框架忽略了游戏设计的实现。</strong>游戏是一个复杂的系统，它同时具有商品、工程和艺术品的性质，MDA将业务逻辑过于抽象的封装在“机制”元素中，缺乏对游戏工程性质的描述。使用MDA解构游戏时可能问题不大，但将MDA用在设计游戏时思路容易受到限制。</p><p><strong>最后，MDA缺乏对体验界定性描述。</strong>MDA理论的文章中，很大程度强调了玩家体验的重要性，却没有对玩家体验进行深入的研究和分类，例如空洞骑士和奥日2，同样是Metroivania作品，但两者强调的体验中心却有很大区别，空洞希望玩家专注于用简单的攻击解决多样的问题，例如利用骨钉攻击造成的回弹辅助位移，而奥日则强调的是同一类问题使用多样化的解决思路，例如利用气泡、猛击或者三级跳符文推进探索。因此，两者强调的体验是完全不同的，玩空洞骑士时，玩家需要更仔细观察BOSS的攻击，突出攻击的节奏；而奥日等多样化的选择，需要玩家熟知个技能的性质，突出攻击的策略。这两种体验如果不去复盘其实很容易混淆，在设计时如果陷入这类误区很容易让游戏的体验低于预期。因此，游戏设计师一定需要有清晰的体验界定能力，而这一点MDA并没有提供多大帮助。</p><p>这些问题也可以理解为MDA的特点或者是优势，<strong>工程忽略性</strong>使其在解构难以复现的大型3A游戏时更加精简，<strong>体验界定和推导的不确定性</strong>也使后来的游戏设计师有更多的理论研究空间。</p><h3 id="FDD"><a href="#FDD" class="headerlink" title="FDD"></a>FDD</h3><p><strong>FDD</strong> 即形式（Formal）、戏剧（Dramatic）、动态（Dynamic Elements），最早从《游戏设计梦工厂》中提出，是更对设计师或学生具有指导意义的分析工具。学习的过程中发现网络上FDD的相关资料实在少得可怜，唯一系统的描述书《游戏设计梦工厂》还没有开读，所以理解十分有限，会在读到《游梦》的时候在再进行更正和修改，这里先从其他游戏设计书籍的复述和网络资料记录下现在浅显的理解。</p><p>对于认知有限的结构首先要做一定是<strong>同类比较</strong>，对比MDA的精简，FDD的三大元素的内容就细致很多：形式元素包括玩家交互模式、目标、规则、过程、资源、边界、结局；戏剧元素包括前提、角色、戏剧；动态元素包括涌现、涌现叙事、试玩。整体来看，这类细致的结构化思维意图很明显，就是能够知道实际的设计开发工作。三大元素下的细节之间的联系虽然不密切，但是都是在提出实际的问题，类似于《游戏设计艺术》中提到的<strong>透镜思维</strong>，透镜就是一系列的自我提问，Jesse Schell希望设计师能在实际开发中经常性的提问反思。实际上，我认为<strong>自问自答是解决实际设计项目基本也是核心方法</strong>。</p><p>简单来看一下FDD的三大元素分别强调了什么。</p><p><strong>形式元素</strong>在时间上强调了游戏目标、流程、结局，在空间上强调了游戏资源、边界，在规则上强调了限制、交互。实际上我这样的归类比较牵强，每个子元素之间的交叉实际很多，例如结局就可能通过包括时间和空间上的终点。但是我们能发现再这样的归类下，<strong>形式元素描述的是游戏的实际表现</strong>，因此设计师可以通过这一系列透镜<strong>复现一款优质游戏的玩法</strong>，从而判断<strong>此类玩法是否适合于其他的场景</strong>。</p><p><strong>戏剧元素</strong>全部描述的文案类的思路，其提到的前提（即世界观）、角色、情节是构成优秀游戏剧本不可或缺的部分，为游戏的剧情分析提供了三个维度。当然这三点一般能容易想到，但戏剧元素强调了<strong>利用剧情帮助玩家理解规则</strong>，例如武士零通过时间类药物解释为什么主角能够频繁读档但是记忆是连续的。因此戏剧元素是在帮助设计师<strong>复现文案的同时与游戏规则有所联系</strong>。</p><p><strong>动态元素</strong>是我理解比较懵的，它没有想MDA中的美学一样脱离游戏关注玩家体验，而是希望设计师去<strong>解释规则与体验间的作用关系</strong>，作者称之为<strong>涌现</strong>，这要求设计对玩家体验有清晰认知同时能够理解游戏规则的内涵。作者也为理解涌现提供了一个方法，充分的试玩和重复测试，说白了就是爆肝。</p><h3 id="四元法"><a href="#四元法" class="headerlink" title="四元法"></a>四元法</h3><p><strong>四元法</strong>即美学、机制、剧情、技术四大元素，Jesse Schell在其《游戏设计艺术》中提出。四元法是本文三类分析框架中实用性最高的（个人观点），常见的游戏行业传统职位都能够根据四元法进行归类（排除技术美术这类交叉职能）。例如概念设计师、原画师、建模师关注美学部分，主策划、系统策划、关卡策划、数值策划主要关注机制部分，文案策划关注剧情部分，客户端工程师、图形工程师、架构工程师关注技术部分。</p><p>此外，四元法分别根据玩家和设计建立一种思维方式，其核心关系如下图。</p><p><img src="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/2.jpg" alt="FDC75F852F7E7972670C41BF68D789D8"></p><p>于<strong>玩家</strong>而言，他们优先关注的是游戏的美学部分，其次是机制和剧情，最后才有一小部分群体会去关注技术（例如一些MOD作者、新设计师），但是于<strong>设计师</strong>而言，这四大元素是<strong>同样重要</strong>的，技术支撑了上层了机制与交互剧情的实现，最后以不同的美学形式展现。四元法和MDA一样同样考虑了玩家与设计师的角度。</p><p>想要更好理解四元法的四大元素，我们需要先理解《游戏设计艺术》一书的结构（然而只是因为我看了说得出来，个人感觉这本书最有用的都是目录前的架构图和一系列透镜了），在描述到游戏元素时Jesse的思维结构如下。</p><p><img src="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/3.jpg" alt="E600E86826260FB697BBF239F69DC58A"></p><p>一句话概括：<strong>游戏设计师本质的工作式设计玩家的体验，体验受限于场景，而游戏作为载体由元素构成并服务于特定主题。</strong>重中之重的是<strong>这四大元素是否都在为同一主题而努力</strong>，例如死亡搁浅，所有的游戏元素都是为了阐述“连接”这一主题，从机制上解锁开罗尔网络和送快递，故事上连接USC和冥滩，美学上BT的“尾巴”和冥滩与生界渗透场景，甚至技术上通过实现“共同基建”的机制将玩家们隐秘的连接起来。因此<strong>四元法的根本目标是服务游戏主题，而主题本质上又是服务于体验。</strong></p><p>基于上述想法我们同样以Jesse的透镜思维来简单理解这四大元素，不细致阐述（因为真的是太多了）。</p><p><strong>机制：</strong>玩家的目标是什么？这一目标服务于什么体验？玩家需要受限于什么规则？规则是否能起到加强玩家游戏理解或是强化体验的作用？玩家这一阶段需要受到什么反馈？这样的反馈能否使玩家保持在心流之中？机制描述了游戏基本运行逻辑，但仍需要下层技术提供实现，并通过上层美学反馈。</p><p><strong>故事：</strong>游戏的故事是要线性的还是碎片化的？这对玩家的游戏体验会造成什么差异？是否会阻碍游戏理解？剧情架构会对玩家的关注点产什么影响？故事同样需要下层技术提供实现，由上层美学反馈。</p><p><strong>美学：</strong>游戏的视觉效果、音效、音乐目的是营造什么体验？如何使用游戏美学让玩家保持沉浸？如何在正确的时机强调游戏美学展现出最大的影响力？美学对玩家体验有直接影响，关键要思考<strong>展现什么？什么时候展现/强调？</strong></p><p><strong>技术：</strong>技术要素比较独特，其本质是一种媒介，<em>美学通过它展现，机制通过它作用，故事通过它讲述</em>，既然是媒介而其根本目的又是服务体验，那最重要的就是<strong>合适</strong>的技术。但需要强调的是，现有的技术实际上服务于未来的游戏，因此技术是否合适还需要从时间发展角度去思考。</p><p>这是我认为四元法需要抓住的核心理解：在四元法的大体的思维架构下，需要同相应的<strong>透镜</strong>，也就是问题，在游戏设计的流程中时刻反思。当然四元法也包含很多实际设计的指导细节，但限于篇幅不予赘述（主要是太多说不明白），如有兴趣可以自读《游戏设计艺术》。</p><p>这里还需要提一下分层四元法，由Jeremy Gibson在《游戏设计、原型与开发：基于Unity与C#从构思 到实现》一书中提出（Unity的部分很老了，建议优先设计部分）。他将四元法分在了内嵌层、动态层 和文化层，对游戏设计的整体思路做出了更多的拓展，实际上分层四元法和Jesse目录的思维导图有很 多相似点，都是从脱离游戏本身而对游戏对玩家、设计师、社群甚至社会的影响进行了拓展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>MDA</strong>展示了玩家与设计师对于游戏不同的思维方式与价值取向，强调设计师应通过玩家视角更完整有 效的审视自己的作品，着重强调了美学，即玩家的游玩体验。<br><strong>FDD</strong>对游戏设计的细节进行了归类并提出了指导性建议，为设计师和学生提供了实质性的帮助，着重强 调了叙事对玩家体验的作用，即叙事涌现。<br><strong>四元法</strong>实际偏向设计师角度去看待游戏，对游戏的元素进行了细致的分类，并提供了学多细节作为指导 性建议，着重强调了游戏-主题-体验的统一。</p>]]></content>
    
    
    <categories>
      
      <category>games</category>
      
    </categories>
    
    
    <tags>
      
      <tag>game design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo和Github快速搭建个人博客</title>
    <link href="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章为纯新手向，主要内容利用github平台快速建立并托管个人Hexo的Next网站，无论文科生和理科生，都能在一个小时左右完成部署，平台为windows。</p><blockquote><p>为阅读本文章，你需要同时阅读：<br><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a><br><a href="https://theme-next.iissnan.com/getting-started.html">Next主题官方文档</a><br><a href="https://github.com/younghz/Markdown">Markdown语法参考</a></p><h2 id="Hexo-Github模式优点"><a href="#Hexo-Github模式优点" class="headerlink" title="Hexo + Github模式优点"></a>Hexo + Github模式优点</h2><ul><li>节省购置服务器的费用</li><li>快速搭建，快速部署</li><li>学习成本低，学习价值高<span id="more"></span><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2>一. 建立github仓库<br>二. 建立本地Hexo博客<br>三. 配置本地Hexo博客<br>四. 连接本地Hexo与gitpages</li></ul></blockquote><h2 id="开始搭建吧！"><a href="#开始搭建吧！" class="headerlink" title="开始搭建吧！"></a>开始搭建吧！</h2><h3 id="建立github仓库"><a href="#建立github仓库" class="headerlink" title="建立github仓库"></a>建立github仓库</h3><p>开始之前确保已注册github帐号并下载gitbash。<br>如果还没有，请参考：<a href="http://wiki.jikexueyuan.com/project/github-basics/sign-up.html">极客学院github初识教程</a>完成注册和下载。</p><blockquote><p>点击创建仓库</p></blockquote><p><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github1.png" alt="github1"></p><blockquote><p>如图输入仓库名，其中方框部分应与github用户名一致</p></blockquote><p><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github2.png" alt="github2"></p><p><strong>强调：红色方框中的输入内容应为用户名，否则无法托管。</strong></p><h3 id="建立本地Hexo博客"><a href="#建立本地Hexo博客" class="headerlink" title="建立本地Hexo博客"></a>建立本地Hexo博客</h3><p>请先自主阅读<a href>Hexo官方文档-概述</a>，若按照官方文档已完成安装，可以跳过该步骤。</p><ol><li><p><strong>安装Node.js</strong><br>从<a href="https://nodejs.org/en/">Node.js官网</a>下载并安装Node.js环境，推荐LTS（Long-Term-Support）版本。</p></li><li><p><strong>本地下载Hexo</strong><br>首先选择你要配置本地博客的目录，右击选择 <strong>Git Bash Here</strong>，<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitbash.png" alt="gitbahs"><br>从而进入如图gitbash环境<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitbash_cli.png" alt="gitbash2"><br><strong>注意：明白这一步直很重要，之后所有命令都是在gitbash中完成！</strong></p></li><li><p><strong>安装hexo</strong><br>gitbash输入:<code>npm install -g hexo-cli</code>会开始安装Hexo，安装完成后会有如图所示目录文件。</p></li></ol><p>各目录的作用请参考：<a href>Hexo官方文档-建站</a></p><h3 id="配置本地Hexo博客"><a href="#配置本地Hexo博客" class="headerlink" title="配置本地Hexo博客"></a>配置本地Hexo博客</h3><p>请先自主阅读<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo官方文档-配置</a>与<a href="https://theme-next.iissnan.com/getting-started.html">NexT官网文档-开始使用</a>，若按照官方文档已完成部署，可以跳过该步骤。</p><ol><li><p><strong>下载并部署NexT主题</strong><br>前往<a href="https://github.com/iissnan/hexo-theme-next/releases">NexT版本发布页面</a>下载官方Source code.zip并解压，将解压后的文件名修改为<strong>next</strong>后置于你本地博客目录的themes文件夹。</p></li><li><p><strong>本地预览</strong><br>在博客目录下的gitbash中输入<br><code>hexo clean</code><br><code>hexo g</code><br>完成初始化，之后使用命令<br><code>hexo s</code><br>完成本地部署。<br>本地部署后可，通过访问<code>localhost:4000</code>从而访问本地博客。至此，你已经可以看到你的博客首页了。<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/预览.png" alt="预览"></p></li></ol><ol><li><p><strong>区别本地配置和主题配置</strong><br>两个配置文件均为<code>_config.yml</code>，但有本质区别，之后配置需注意不要混淆。<br><strong>本地配置</strong>：位于 本地博客根目录下<code>_config.yml</code><br><strong>主题配置</strong>：位于 本地博客目录/themes/主题目录(如next)下的<code>_config.yml</code></p></li><li><p><strong>配置本地配置</strong><br>打开本地配置的<code>_config.yml</code>，找到如图Themes字段：<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/theme.png" alt="theme"><br>将字段修改为<code>theme: next</code>从而应用布置好的NexT主题<br>同样可以找到如图字段：<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/site.png" alt="site"><br>将language字段修改为<code>language: zh-Hans</code>即可应用主题为中文版，在其他字段中可以直接修改个人博客的标题、子标题、描述等信息。</p></li></ol><ol><li><p><strong>配置主题配置</strong><br>打开主题配置中的<code>_config.yml</code>可以看到主题配置内容，此步骤只强调几个终点配置。</p><ul><li><strong>配置菜单</strong><br>找到如图menu配置，修改menu中的字段对应博客主页菜单的变化<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/menu.png" alt="menu"></li><li><p><strong>配置NexT主题</strong><br>找到如图Schemes配置，修改scheme字段可以修改NexT子主题<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/scheme.png" alt="scheme"></p></li><li><p><strong>配置博客头像</strong><br>在配置文件任意独立行输入<code>avatar: /images/avatar.png</code>，之后在本地博客目录下<code>source</code>文件夹下新建文件夹<code>images</code>，选择自己喜欢的博客头像改为<code>avatar.png</code>同名文件放置在该目录下即可。</p></li><li><p><strong>配置favicon图标</strong><br>所谓favicon如图，可以想<code>images</code>文件夹下添加名为<code>favicon.ico</code>的图标文件修改。</p></li></ul></li></ol><h3 id="连接本地Hexo和gitpages"><a href="#连接本地Hexo和gitpages" class="headerlink" title="连接本地Hexo和gitpages"></a>连接本地Hexo和gitpages</h3><ol><li><p><strong>配置与Github Pages关联</strong><br>打开本地配置的<code>_config.yml</code>，找到如图deploy字段：<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt="deploy">并如图配置,其中红框为你的github帐号，白框为github密码，灰框(最右)为你建立的仓库地址。</p></li><li><p><strong>部署github托管</strong><br>很简单，本地博客目录打开gitbash，输入<code>hexo d</code>即完成在线部署。<br><strong>至此，你的个人博客线上部署已经完成！</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>next-theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
