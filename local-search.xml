<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>GAMES101 - 实验环境搭建</title>
    <link href="/2020/12/05/GAMES101-LAB/"/>
    <url>/2020/12/05/GAMES101-LAB/</url>
    
    <content type="html"><![CDATA[<h3 id="GAMES101-Vscode可行配置"><a href="#GAMES101-Vscode可行配置" class="headerlink" title="GAMES101 Vscode可行配置"></a>GAMES101 Vscode可行配置</h3><p>环境：Vscode + CMakeTools + CppTools + Mingw64</p><p>Vscode中C++引入第三方库的方式大致有以下三种：</p><ol><li>对于非Cmake项目，利用CppTools（Miscrosoft官方为Vscode提供的编译和调试插件）的IntelliSense功能，通过设置<code>c_cpp_properties.json</code>中的includePath项引入对应库的<code>/include</code>目录。</li><li>对于Cmake项目，利用CMakeTools （Miscrosoft官方为Vscode提供的Cmake插件）一键基于<code>CMakeList.txt</code>生成<code>/build</code>目录，在通过内置终端make并运行。</li><li><p>对于Cmake项目，同时使用CppTools与CMakeTools ，高度自动化的预设置支持一键build和一键debug，在配置合理的情况下这种方式是最高效的。麻烦点在于需要对<code>setting.json</code>，<code>c_cpp_properties.json</code>，<code>task.json</code>，<code>launch.json</code>进行额外配置。假设使用windows下以mingw64为编译器，具体改动如下。</p><ul><li><p><code>setting.json</code>。在工作区配置中将<em>C_Cpp.default.configurationProvider</em>设置为<em>ms-vscode.cmake-tools</em>，表示通过CMakeTools 引入外部链接而不是内置的includePath。</p></li><li><p><code>c_cpp_properties.json</code>。如果在<code>setting.json</code>中已配置或配置失效，可以添加<em>configurationProvider</em>设置为<em>ms-vscode.cmake-tool</em>从而实现同样的引入效果，两者不冲突。</p></li><li><p><code>task.json</code>。由于CMakeTools 在<code>CMakeList.txt</code>保持的时候就完成了build，因此只需提供make的任务指令即可，具体指令根据环境变量的设置而变，一般为make或mingw32-make，json配置如下</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-comment">// tasks下添加</span>&#123;            <span class="hljs-attr">&quot;label&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>,            <span class="hljs-attr">&quot;options&quot;</span>: &#123;                <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;/build&quot;</span>            &#125;,            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;shell&quot;</span>,            <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;mingw32-make -j4&quot;</span>, &#125;</code></pre></div></li><li><p><code>launch.json</code>。注意指定正确的miDebuggerPath和program，并加载<code>task.json</code>中新添加的make为前置任务，json配置如下（Assignments2为例）</p><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;configurations&quot;</span>: [        &#123;            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;debug&quot;</span>,            <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;cppdbg&quot;</span>,            <span class="hljs-attr">&quot;request&quot;</span>: <span class="hljs-string">&quot;launch&quot;</span>,            <span class="hljs-attr">&quot;program&quot;</span>: <span class="hljs-string">&quot;$&#123;fileDirname&#125;\\build\\Rasterizer.exe&quot;</span>,            <span class="hljs-attr">&quot;args&quot;</span>: [],            <span class="hljs-attr">&quot;stopAtEntry&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;cwd&quot;</span>: <span class="hljs-string">&quot;$&#123;workspaceFolder&#125;&quot;</span>,            <span class="hljs-attr">&quot;environment&quot;</span>: [],            <span class="hljs-attr">&quot;externalConsole&quot;</span>: <span class="hljs-literal">false</span>,            <span class="hljs-attr">&quot;MIMode&quot;</span>: <span class="hljs-string">&quot;gdb&quot;</span>,            <span class="hljs-attr">&quot;miDebuggerPath&quot;</span>: <span class="hljs-string">&quot;D:\\MinGW\\mingw64\\bin\\gdb.exe&quot;</span>,            <span class="hljs-attr">&quot;setupCommands&quot;</span>: [                &#123;                    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;为 gdb 启用整齐打印&quot;</span>,                    <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;-enable-pretty-printing&quot;</span>,                    <span class="hljs-attr">&quot;ignoreFailures&quot;</span>: <span class="hljs-literal">true</span>                &#125;            ],            <span class="hljs-attr">&quot;preLaunchTask&quot;</span>: <span class="hljs-string">&quot;make&quot;</span>        &#125;    ]</code></pre></div></li></ul></li></ol><h3 id="其他坑"><a href="#其他坑" class="headerlink" title="其他坑"></a>其他坑</h3><ol><li>eigen和opencv自带include文件无法被正确引入时，需要自己用Cmake进行本地构建和编译，这里的坑搜一下网上的文章基本能解决。</li><li>在用mingw本地编译opencv时需要使用mingw64-posix离线版，online版的选了posix还不行。</li><li>CMakeList.txt找不着包，是环境变量没有被正确配置。所幸GAMES101的助教提供了写好的CMakeList作为参照，把拥有<code>xxxconfig.cmake</code>的目录添加到对应的环境变量即可（例如设置OpenCv DIR目录为包含<code>opencvconfig.cmake</code>的路径），不必绕进cmake的一堆坑。</li></ol>]]></content>
    
    
    <categories>
      
      <category>graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer-graphics</tag>
      
      <tag>fundamentals</tag>
      
      <tag>env-config</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GAMES101 - 现代计算机图形学入门</title>
    <link href="/2020/11/27/GAMES101/"/>
    <url>/2020/11/27/GAMES101/</url>
    
    <content type="html"><![CDATA[<h3 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h3><p>GAMES101是GAMES (<em>Graphics And Mixed Environment Seminar</em>）系列公益课程的第一部，授课老师为UCSB的助理教授闫令琪老师。GAMES101因为专注于原理的分析与解释，并提供了BBS、助教和作业提交系统等一套完备的学习设施，课程质量广受好评。课程地址：<a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html</a></p><p>本文章主要包括以下几个内容：</p><ul><li>计算机图形学基本原理和分析方法的记录</li><li>该课程作业分析和解决方案</li><li>该课程的部分涉及内容的拓展</li></ul><p>本人容易遗忘原理类的知识，所以做好记录还是蛮有必要的。本文不属于详尽的内容笔记，倾向于记录学习中主观容易遗忘的重点难点。</p><!-- toc --><span id="more"></span><h3 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h3><p><img src="/2020/11/27/GAMES101/image-20201127165907506.png" alt></p><h4 id="Covered-Topics"><a href="#Covered-Topics" class="headerlink" title="Covered Topics"></a>Covered Topics</h4><ul><li>Rasterization</li><li>Curves and Meshes</li><li>Ray Tracing</li><li>Animation / Simulation</li></ul><h4 id="References"><a href="#References" class="headerlink" title="References"></a>References</h4><blockquote><p>Fundamentals Of Computer Graphics 3th Edition</p></blockquote><h3 id="Transformation"><a href="#Transformation" class="headerlink" title="Transformation"></a>Transformation</h3><p>图形学中 Transformation 的核心问题是找到一个变换矩阵 $ M $ ，使得空间中任意一个Vetcor可以利用$M$ 进行缩放、反转、切边、旋转和平移。其中平移变换的引入需要利用齐次坐标表示$M$的仿射变换，因此，在三维向量空间中$M$应为一个4x4的矩阵。 Transformation的所有内容将基于齐次坐标构建的变换矩阵。Transformation中一个重要假设是任何复合变换都可以依次分解为各个独立变换，复合变换中，优先平移，其次线性变换。</p><h4 id="点和向量的表示"><a href="#点和向量的表示" class="headerlink" title="点和向量的表示"></a>点和向量的表示</h4><p><strong>Point</strong> = $(x,y,z,1)^\intercal$ or $(wx,wy,wz,w)^\intercal$ subject to $w&gt;0$</p><p><strong>Vector </strong>= $(x,y,z,0)^\intercal$（$w=0$实际上保护了Vector的平移不变性）</p><h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><script type="math/tex; mode=display">M =  \left[ \begin{matrix}   S_x & 0 & 0 & 0\\   0 & S_y & 0 & 0\\  0 & 0 & S_z & 0\\0 & 0 & 0 & 1\end{matrix}  \right]</script><h4 id="Reflection"><a href="#Reflection" class="headerlink" title="Reflection"></a>Reflection</h4><ul><li>以x-axis为例， y-axis, z-axis 同理。</li></ul><script type="math/tex; mode=display">M =  \left[ \begin{matrix}   -1 & 0 & 0 & 0\\   0 & 1 & 0 & 0\\  0 & 0 & 1 & 0\\0 & 0 & 0 & 1\end{matrix}  \right]</script><h4 id="Rotation"><a href="#Rotation" class="headerlink" title="Rotation"></a>Rotation</h4><ul><li>Default<ul><li>(0, 0, 0)为原圆心</li><li>逆时针</li></ul></li><li>由于Rotation的输入为角度$\theta$，其变换矩阵的逆刚好等于转置，满足正交矩阵性质。该性质简化了视图变换$M$的推导。</li></ul><p>以沿x-axis旋转为例， y-axis, z-axis 同理。</p><script type="math/tex; mode=display">\left[ \begin{matrix}   1 & 0 & 0 & 0\\   0 & \cos\theta & -\sin\theta & 0\\  0 & \sin\theta & \cos\theta & 0\\0 & 0 & 0 & 1\end{matrix}  \right]</script><ul><li><p>Rotation也满足Transformation复合叠加的假设</p><script type="math/tex; mode=display">R_{xyz}(\alpha,\beta,\gamma)=R_x(\alpha)R_y(\beta)R_z(\gamma)</script></li><li><p>Rodrigues’ rotation formula</p><p>罗德里格旋转公式是表达三维空间的另一种形式，其输入不再是三个轴上的旋转角度，而是选择一个单位向量 $n$ 作为旋转轴，以及 $\alpha$ 作为绕该单位向量旋转角度，公式如下：</p><p><img src="/2020/11/27/GAMES101/image-20201127194327234.png" alt="image-20201127194327234"></p></li></ul><h4 id="View-Transform"><a href="#View-Transform" class="headerlink" title="View Transform"></a>View Transform</h4><h5 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h5><p>一个3D空间向2D投影的过程包括三步：</p><ol><li>model transform</li><li>view transform</li><li>projection transform</li></ol><p>对于View Transform， 我们定义空间中的一个相机为 $(e,g,t)$，分别代表相机的Position, Look-at Direction, Up Direction（该向量定义正交于$g$）。View Transform的目标是找到一个变换矩阵<script type="math/tex">M_{view} = R_{view}T_{view}</script>，使得相机的Position回到原点，Look-At Direction面向<script type="math/tex">-z</script>， Up Direction面向<script type="math/tex">y</script></p><p><img src="/2020/11/27/GAMES101/image-20201127201909367.png" alt="image-20201127201909367"></p><p>这里运用了旋转矩阵作为正交矩阵的性质，矩阵的逆等于矩阵的转置，更加直观。</p><h4 id="Projection-Transform"><a href="#Projection-Transform" class="headerlink" title="Projection Transform"></a>Projection Transform</h4><ul><li>Orthographic Transform</li><li>Perspective Transform</li></ul><p><img src="/2020/11/27/GAMES101/image-20201127202458361.png" alt="image-20201127202458361"></p><p><img src="/2020/11/27/GAMES101/image-20201127202533997.png" alt="image-20201127202533997"></p><h5 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h5><p>投影变换是将3D空间信息转换为2D信息，而投影分为正交投影和透视投影，两者区别就是相机与近视屏幕的距离是否为无限。实现投影变换一个简单的思路就是去轴，例如通过移除Z轴我们就得到了X-Y平面的投影信息。但是显然这种方法是有缺陷的，大多时候我们期望投影变换后不会损失三维空间的信息。换言之，投影变换需要保留近视平面到远视平面形成的整个可视空间的信息。</p><p>因此，投影变换的目的是<strong>可视空间投影到一个以原点为中心的[1,1,1]的正则空间(canonical cube)</strong></p><h5 id="Orthographic-Transform"><a href="#Orthographic-Transform" class="headerlink" title="Orthographic Transform"></a>Orthographic Transform</h5><p><img src="/2020/11/27/GAMES101/image-20201127203648697.png" alt="image-20201127203648697"></p><h5 id="Perspective-Transform"><a href="#Perspective-Transform" class="headerlink" title="Perspective Transform"></a>Perspective Transform</h5><p>透视变换略微比正交变换复杂，因为透视相机的可视空间是一个截锥体（Frustum），这里闫老师给了一种很好理解的方式，我们先把Frustum转换为Cubiod，再使用Orthographic Transform的转换矩阵即可。而Frustum转换为Cubiod的推导也很有意思。</p><p>我们希望Frustum转换为Cubiod，首先需要使近远视平面大小一致，由于相机更接近于近视平面所以我们希望远视平面变小，就像四个手指头挤压远视平面一样。因此有如下条件</p><ol><li>相机已完成视图变换</li><li>近视平面上的点恒定不变</li><li>远视平面上点的Z轴信息恒定不变</li></ol><p>设近视平面上的点为$(x’,y’,z’)$，远视平面上的点$(x,y,z)$，分别以$-x$和$-y$的角度去观测Frustum，根据相似三角形的信息，我们可以得到</p><p><img src="/2020/11/27/GAMES101/image-20201127210322765.png" alt="image-20201127210322765"></p><p><img src="/2020/11/27/GAMES101/image-20201127210332807.png" alt="image-20201127210332807"></p><p>对于远视平面上的任意点，在齐次坐标下我们可以表示为</p><p><img src="/2020/11/27/GAMES101/image-20201127210436925.png" alt="image-20201127210436925"></p><p>可以腿短$M_{persp\rightarrow ortho}$满足</p><p><img src="/2020/11/27/GAMES101/image-20201127210644723.png" alt="image-20201127210644723"></p><p><img src="/2020/11/27/GAMES101/image-20201127210655158.png" alt="image-20201127210655158"></p><p>现在我们只有第三行的四个信息未知，再利用假设2可以得到</p><p><img src="/2020/11/27/GAMES101/image-20201127211002360.png" alt="image-20201127211002360"></p><p><img src="/2020/11/27/GAMES101/image-20201127211010418.png" alt="image-20201127211010418"></p><p>假设3可以得到</p><p><img src="/2020/11/27/GAMES101/image-20201127211022450.png" alt="image-20201127211022450"></p><p>最后得出A,B</p><p><img src="/2020/11/27/GAMES101/image-20201127211039149.png" alt="image-20201127211039149"></p><p>本节的思考题是在可视空间中非视平面上的点的Z轴的值是如何变化的，直观的感受我们知道Z轴的值肯定是变大的（因为远小），也可以利用矩阵计算验证，如下。</p><p><img src="/2020/11/27/GAMES101/44B0C4A76D6E4E248776D089B16AA050.png" alt="img" style="zoom:50%;"></p><h3 id="Rasterization"><a href="#Rasterization" class="headerlink" title="Rasterization"></a>Rasterization</h3><p>光栅化 (Rasterization) 是原德语的音译，实际做的就是把正则观测矩阵的信息投在屏幕上。</p><ul><li>Field-of-View (FOV) 相机到近平面中点的连线与其到近平面边的连线的夹角</li><li>Aspect Ratio 横纵比 <script type="math/tex">\frac WH</script></li></ul><p>本章节定义屏幕像素是一个由RGB三色空间组成的纯色块，采用XY平面坐标系。Raster要做的是把连续的图像信息投影到离散的像素平面上，首先利用<script type="math/tex">M_{viewport}</script>将观测平面大小拉伸至屏幕平面大小，然后对观测空间中的三角形做离散采样。第二步具体表现为，根据每个三角形的顶点坐标定义一个操作空间，之后对操作空间每一个像素点经过<script type="math/tex">inside(tri,x,y)</script>函数判断其是否处在三角形内（叉乘的性质），从而判断某一像素是否需要被投影（渲染？）</p><p>这里有几个假设需要提及</p><ol><li><p>选择三角形的原因</p><p>a. 最简单的多边形</p><p>b. 三角形的三个顶点一定在一个平面，不存在凹运算</p><p>c. 与b相似，由于三角形不存在凹运算因此内外的定义也很直接</p></li><li><p>假设像素是投影的最小单元，每个像素仅有一个采样点为其中点。</p></li><li>采样方式不一定是选取操作空间，也可以选取一个顶点作为根进行遍历。</li></ol><p><img src="/2020/11/27/GAMES101/image-20201128213237552.png" alt="image-20201128213237552"></p><h4 id="Antialiasing"><a href="#Antialiasing" class="headerlink" title="Antialiasing"></a>Antialiasing</h4><p>既然是采样，肯定就要涉及奈奎斯特-香农采样定理，也肯定要涉及Aliasing（信号中译为混叠，图形学译为锯齿），为了实现Antialiasing，就需要补充一些信号与系统在图形学中的解释。</p><p><img src="/2020/11/27/GAMES101/image-20201128214234227.png" alt="image-20201128214234227" style="zoom:50%;"></p><p>我们假设图像信号是连续的波形函数，在频域中我们可以通过傅里叶级数将其分解多个不同频率的简谐函数。我们想象计算机以特定频率<script type="math/tex">F</script>进行采样，如果其中的某一条简谐信号的频率<script type="math/tex">F'</script>远大于<script type="math/tex">F</script>，这个频率下的信息就被错误采样了。这就导致了Aliasing。</p><p><img src="/2020/11/27/GAMES101/image-20201128215717490.png" alt="image-20201128215717490" style="zoom:50%;"></p><p>显然我们不能对单一的简谐信号操作，想要使特定频率的不被采用只需要对原信号进行滤波即可，而对于图像想好的滤波，直观上有一些比较有趣的结果。</p><p><img src="/2020/11/27/GAMES101/image-20201128215938138.png" alt="image-20201128215938138" style="zoom:67%;"></p><p><img src="/2020/11/27/GAMES101/image-20201128215958829.png" alt="image-20201128215958829" style="zoom:67%;"></p><p><img src="/2020/11/27/GAMES101/image-20201128220011302.png" alt="image-20201128220011302" style="zoom:67%;"></p><p>由图可知，高频保存了边界信息，而低频保存了变化幅度较低的色块信息。解释一下频域图里的横竖亮线，这是由于图像时域信号假设中是在XY两个方向上无穷的，亮线的部分实际就是边界的突变。（这里提一下，我之前看到对抗攻击的防御中，就有通过频域识别扰动的方法，研究结果表明对抗生成的样本在频域图下不止一个高亮点，而是多个高亮点等距离分部）我们用盒形的卷积滤波器的到的图像如下。</p><p><img src="/2020/11/27/GAMES101/image-20201128220805165.png" alt="image-20201128220805165" style="zoom:67%;"></p><p>以特定频率采样，这个过程实际上就是把图像信号的原始信息进行复制粘贴。（卷积的性质）<img src="/2020/11/27/GAMES101/image-20201128221214621.png" alt="image-20201128221214621"></p><p>于是图像学的Aliasing和信号系统的联系了起来</p><p><img src="/2020/11/27/GAMES101/image-20201128221416006.png" alt="image-20201128221416006" style="zoom:67%;"></p><p>解决方法也很直接</p><ol><li>提高采样频率</li><li>整个低通滤波器</li></ol><p>然而在每个像素不止一个采样点的假设下，就能有一种更优的方案。根据每个像素中三角形内的采样点占总采样点数目的比例，我们可以动态的决定每一个像素要如何滤波，而不是对整体运用一个滤波器。这样相当于用更多的采样点换取更少的计算量。这也是MSAA的核心思路。</p><h4 id="Antialiasing-Today"><a href="#Antialiasing-Today" class="headerlink" title="Antialiasing Today"></a>Antialiasing Today</h4><p><img src="/2020/11/27/GAMES101/image-20201128222401408.png" alt="image-20201128222401408"></p><p>这里简要介绍一下，FXAA就是拓展了MSAA的假设，即每个像素内的采样点分布不是均匀的，而会根据光栅化类型利用一些算法智能分布。TAA则是通过前一帧或前几帧的采样点设置信息来动态的设置本该帧某些特定的采样点，相当于是将计算在时间上打乱了，目前得到了业界的一致好评。</p>]]></content>
    
    
    <categories>
      
      <category>graphics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer-graphics</tag>
      
      <tag>fundamentals</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GameJam - LudumDare46</title>
    <link href="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/"/>
    <url>/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本着「 Learning by Doing 」的想法，刚入坑两周的我决定参加LudumDare46去体验完整的小游戏开发过程，由于并没有学过原型实现工具，因此工程上就采用速成的U3D，美术素材部分基于现有素材的二次修改，其余用Aseprite绘制，音乐选自opengameart.org的Dont touch it，个人觉得不错就使用了。</p><p><img src="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/find.png" alt></p><span id="more"></span><h3 id="Day1：-构思想法，实现原型"><a href="#Day1：-构思想法，实现原型" class="headerlink" title="Day1： 构思想法，实现原型"></a>Day1： 构思想法，实现原型</h3><p>第一天公布早上八点半起床，嗦碗粉到九点Twitter确认主题 <em>Keep it alive</em>。当时U3D技术水平只做过一些2D Platformer的实现，因此我能做的游戏形式并没有多少选择。很快我就决定做2D Platformer了，综合看来这一唯一可行的方案，回到主题 <em>Keep it alive</em>，当时立刻想到了一款忘记名字的游戏Demo，主角的生命进入倒计时，通过击杀敌人可以延续倒计时时长，玩家需要在固定场景内击杀不断涌现的敌人来延续生命（怒火攻心内味）。</p><p>但是这种方案对我来说工作量可能较大，而且这个想法比较容易想到，就没有采用。之后我基本上是围绕 <em>it</em> 去想，代入了很多游戏元素，最后决定让 <em>it</em> = <em>the camera</em>，让玩家需要时刻保持游戏镜头的移动否则镜头会持续缩小，而移动会让镜头逐渐增大。</p><p>镜头大小影响的核心机制肯定是探索和寻找，因此我没有多想就把游戏目标设为「 在一个开放场景下找到这个游戏的作者，然后Beat his ass off 」。</p><p>由于玩家需要持续移动，所以2D Plateformer的移动系统一定要做好，要能够给玩家足够的移动控件，最后我决定参考《蔚蓝》的移动系统，将比较断节奏的爬墙改成了持续蹬墙。</p><p>然后是决定游戏的互动机制，因为Jam作品要求小而精，所以在确定奖惩机制后如何互动的问题也就解决了，传统2D Plateformer里的尖刺、电锯啥的元素肯定都有（我也搞不出新的素材）。最后决定奖惩也围绕着核心机制设计：受伤缩小镜头，使用消耗品药片增大镜头。</p><p>大概下午1点左右就基本确定了核心机制、游戏目标、移动系统和反馈机制，然后…..我就摸鱼去了，摸到3点开始用U3D做原型，晚上11点基本写完，查文档和论坛找解决方案的过程着实痛苦，那天晚上整个人昏昏沉沉的，像条死鱼。</p><p><img src="https://media.giphy.com/media/VdWXU2JnrCstn0oSMs/giphy.gif" alt></p><h3 id="Day2-优化机制，搞定美术"><a href="#Day2-优化机制，搞定美术" class="headerlink" title="Day2: 优化机制，搞定美术"></a>Day2: 优化机制，搞定美术</h3><p>第二天啥时候起的给忘了，总之是摸鱼到了中午才开始做。内容是优化原先设计的机制，主要分两点：一是调整手感，二是精简内容。调整手感本质上就是调整一系列动力参数，什么JumpForce, runSpeed, dashSpeed这些， 整个过程有DL炼丹内味了，总之就是不断的试错调整。精简内容上主要是删除了一些游戏元素，删掉了前一天做的磁力装置，考虑到磁力装置更多要求的玩家在慢节奏下做策略决定，然后确定了游戏元素的范围。</p><p>然后是美术，这一点我不头大，我完全了解自己的上限，绘制简易Item动画和Tilemap就行，人物动作素材必须找，自己画就过于抽象了。</p><p>人物素材就用了一个比较经典的 Virtual Boy 形象，B站不少UP的案例里用的也是这个，然后用Aseprite修改颜色统一素材基调。Item和Map素材比较简单就用Aseprite绘制了（因为Procreate怎么设置笔刷像素点都会扩散）。</p><p><img src="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/asset.png" alt></p><h3 id="Day3：爆肝场景，解决杂项"><a href="#Day3：爆肝场景，解决杂项" class="headerlink" title="Day3：爆肝场景，解决杂项"></a>Day3：爆肝场景，解决杂项</h3><p>这一天基本都在做场景，当时还挺急的，一方面既然寻找是玩家的目标那么场景不能太小，另一方面绘制想metroidvania的大场景我没有经验，最后的场景基本就是一些小谜题放至在大场景框架下的不同地方。</p><p>而且，在做场景期间我突然想到个点子，让玩家有能力与地图中的Item交换位置，这样玩家就有能力自己改变地形。当时没多想就去肝这个功能去了，最后完是完成了，但场景还有大半没做完，所有有些场景做的比较草率。</p><p>然后就是杂项，音乐、UI、发布、托管这些基本都是按照最简单的方式去做的，音乐的话我觉得选的Dont touch it 还是不错的，音效没有找到适合的自己也不敢做就放弃了；UI也是精简为主，一个显示药品余量，一个表示镜头大小。最后就是itch托管和ludumdare发布，当时以为发布的游戏内容可以修改的，就没有挂图片，只提供了个Windows版的，后来发现改不了，有点难受。</p><p><img src="/2020/04/21/LudumDare46-Jam%E7%BA%AA%E5%AE%9E/start.png" alt></p><h3 id="关于游戏"><a href="#关于游戏" class="headerlink" title="关于游戏"></a>关于游戏</h3><p>以下是我写在KeepTheCamAive的游戏介绍</p><blockquote><p>You going to find the author of this game and beat his ass off(in game!), and always remember Keep the Camera Alive. </p><p>↑↓←→ to move; Z to Dash; X to Throw ; C to Switch; E to Eat</p></blockquote><p>这里有个操作想稍微解释下（当时给朋友玩他就没懂），X会扔出一个小球，小球扔到游戏内某些Item会消失（原本想做一个爆炸的动画，但是忘掉了…），此时玩家就与这个Item联系上了，然后再Switch…..</p><h3 id="经历反思"><a href="#经历反思" class="headerlink" title="经历反思"></a>经历反思</h3><p>整个过程体验其实比较憋屈，主要原因还是自己太菜了，没有能力快速实现自己的想法。而对于Jam而言，我的所有想法都受限于我的技术水平（我不敢跳脱出2D Plateformer），单从技术上去看，也没有用到U3D的一些关键技术URP啊Shader啊，最后有些问题我都没有解决，比如游戏画面的闪白线条，可能是由于素材重叠造成的，但是尝试了一系列解决方案后都无效。还是因为缺乏对图形学基本原理和引擎操作的扎实基础。</p><p>收获仍然是有的，自己也算是经历了一款小游戏从设计到实现到优化到发布的全过程，好歹算是做出了个作品。</p><p>LudumDare主要关注的仍然是创意和游戏音画的综合表现，但好的创意和想法，在这72h里也需要扎实的技术基础去实现，提高技术的深度和广度是提升Jam水平的重要方式。音画技能的基本技能也需要具备，当然更好的方式是合作。</p>]]></content>
    
    
    <categories>
      
      <category>gamejam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>metriodvania</tag>
      
      <tag>game dev</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ori and the will of the wisps 游玩体验</title>
    <link href="/2020/03/15/Ori%20and%20the%20will%20of%20the%20wisps%20%E6%B8%B8%E7%8E%A9%E4%BD%93%E9%AA%8C/"/>
    <url>/2020/03/15/Ori%20and%20the%20will%20of%20the%20wisps%20%E6%B8%B8%E7%8E%A9%E4%BD%93%E9%AA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文行文比较随意，作为即时记录通关之后的想法。</p><p>主要思考了下第二部在level-up机制，boss战，核心玩法上的改变。</p><span id="more"></span><h3 id="安全区"><a href="#安全区" class="headerlink" title="安全区"></a><strong>安全区</strong></h3><p>设立了一个类似基地和安全区一样的场景——泉源林地，在这里你可以和基莫聊天，了解它们的故事，可以和各类功能性NPC对话提升自己的能力，同样通过以种树和修缮的方式看到自己冒险对森林和栖息之中的生物带来的改变。“安全区”的设定容易与剧情关联增强代入感，同时提供更持久更完整且贯穿游戏主线的反馈。</p><h3 id="Level-up机制"><a href="#Level-up机制" class="headerlink" title="Level-up机制"></a><strong>Level-up机制</strong></h3><p>Level-up机制：奥日中的level-up机制主要由精灵碎片（装备）和精灵技能（技能）组成。精灵碎片可以通过地图探索或精灵之光获得，升级则中能通过精灵之光；精灵技能可以通过探索吸收精灵之树获得，或者通过精灵之光购买。这种level-up机制显然提供了更多样性的体验，Ori2 将游戏的探索体验和战斗体验大致分离，分别由碎片和技能两个不同的机制承担，但探索和战斗的分离却不是完全独立的，精灵碎片同样提供了战斗加成（例如增伤和减防等熟悉BUFF），精灵技能同样为探索提供了便利（炮弹跳跃，精灵猛击，闪光，灵光迸发，煽动），但是不难发现，技能对探索和碎片对战斗提供的帮助并不是必要的，但是能够提供非常多样的游戏策略和体验。</p><p>以精灵碎片和精灵技能作为主导，以精灵生命、精灵能量和碎片栏位提供基本属性加强，就是Ori2基本的level-up机制，也是提供本质体验的游戏机制。我记忆中前作的三维线性技能树，三条线分别管理战斗、属性、探索，都使用技能加点的机制来推进，而Ori2这种明确特定机制创造特定体验更符合设计直觉和设计逻辑，而这种机制-体验对应的设计也并非完全分离的，部分非必要机制的交错往往可以增强体验的多样性，这种设计方法虽然看似基础仍是值得学习并贯穿游戏设计的全过程。</p><h3 id="BOSS战"><a href="#BOSS战" class="headerlink" title="BOSS战"></a><strong>BOSS战</strong></h3><p>BOSS战设计：游戏中总共6个BOSS，老狼，蜘蛛，青蛙，甲虫，大鸟和…石头圈？Metroidvania游戏拥有景深的BOSS设计是个难点，主要难在设计合理的碰撞体的同时还要保证其与动画效果的契合。例如DeadCell的巨人，动画效果让人感觉是拳头在带动肢体，Skeleton仍然有僵硬感。蜘蛛和大鸟在这一点上很优秀，动画效果流畅得让人怀疑他们根本没做Skeleton。单看BOSS机制的话总的来说比较传统，有景深的碰撞体放头部，没景深的全身碰撞体，放技能你就躲，放完技能僵直你就揍他，玩家唯一能选择就是如何揍他，BOSS战线性感十足，难度也不大，基本交完学费而且不像我这么手残就能很轻松过。</p><p>这里我想提一下蜘蛛的BOSS战，尤其是召唤的三只小蜘蛛，感觉简直无处不在，我回去看自己的视频好多遍都没有看懂这个算法的。但是有几个现象是可以描述的：</p><p>a. 小蜘蛛很少选择主动攻击玩家，更倾向于在玩家一定距离内停顿。</p><p>b. 在墙面的停顿时间受与玩家距离影响，距离越远，停顿越久，在地面则没有影响。</p><p>c. 三只小蜘蛛中总有一只会一直跟着玩家走，其余的偏向于停留。</p><p>这会形成一个什么作用呢？例如，玩家带着两只小蜘蛛上了墙面，之后玩家利用Dash和猛击快速转移到另一侧，此时两只小蜘蛛会受条件b的限制，在墙面停留很长时间，当玩家重新回到原本的墙面附近导致小蜘蛛停留时间缩短，其中一只在条件c下小蜘蛛会提前移动，当玩家躲过条件c小蜘蛛，另一只墙面上的蜘蛛会在条件b的影响下移动并和之前的小蜘蛛的形成包夹。这就是为什么在蜘蛛BOSS战感觉小蜘蛛无处不在的原因，不同的AI改变了小蜘蛛的停顿时间，从而形成了“包夹”的效果。虽然上述条件只是根据自己视频回顾的猜测，但游戏体验告诉我小蜘蛛的算法绝对不会是简单的随机，大概率有吃豆人幽灵类似的AI设计。如何用三只小蜘蛛制造无处不在和包夹的效果是很值得摸索的。</p><h3 id="核心玩法设计"><a href="#核心玩法设计" class="headerlink" title="核心玩法设计"></a><strong>核心玩法设计</strong></h3><p>Ori区别于其他Metroidvania的玩法实际上是追逐战和猛击。</p><p>追逐战是一种线性化和模式化明显的玩法，所以设计重点就应该放在场景、难度和画面上。Ori的场景设计是非常优秀的，将沙盒场景作为追逐战场景会造成许多困难，要求场景设计时需要兼顾可探索性与追逐战的流畅性，大部分设计师在设计追逐战时都会选择一个特定的不可重复探索的场景，例如武士零里的机车追逐和我的朋友佩德罗里的坠落战。ori的场景很好的兼容这两点，谁能想到第一次遇到触手怪的地方居然会有一大坨精灵之光呢。难度实际上决定于场景和一些设计技巧，例如橡皮筋法则，当你距离怪物近的时候，怪物会减速你会加速，场景坍塌速度也会减慢，而当你距离怪物远的时候，怪物会加速你会减速，场景探索速度也变快，就像被框在一个橡皮筋里一样，这样动态难度的设定是平衡难度很好的方法，也十分常见，像神海和古墓类似作品里经常采用。画面就不必多说了，没有艺术细菌的我只能赞叹Ori追逐战力每一帧画面都是艺术品。</p><p>第二个核心玩法猛击，是Ori区别于其他Metroidvania的最大特点，Ori必须要键鼠操作也因如此。这个玩法几乎贯穿了整个游戏流程，你需要用猛击进行地图探索，逃离追逐并且反击BOSS的攻击，更巧妙的是，猛击引入了时停的效果，并借此控制了游戏难度、玩家的注意力和心流。猛击效果简单反馈迅速，却对游戏各方面的设计起到了举足轻重的影响，是一个非常天才的设计，甚至可以说Ori其他玩法都是用来服务这一项机制的。</p><h3 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a><strong>一些问题</strong></h3><p>a. 大量新机制的引入却没有更大的场景提供发挥空间。</p><p>b. 一些无意义的精灵碎片</p><p>c. 甲虫和石头圈这种不明所以的BOSS</p><p>d. 意义不明的装备系统却装满了任务道具</p><p>e. 如果多一些支线那就更好了</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><ol><li>“安全区”的设计参考</li><li>一个机制对应一个玩法对应一个体验，但要有交错</li><li>敌人的AI设计值得考究</li><li>BOSS战去线性化的一个方法：引入其他敌人（小蜘蛛）形成多线</li><li>把握核心玩法，控制游戏体量</li></ol>]]></content>
    
    
    <categories>
      
      <category>games</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ori</tag>
      
      <tag>games</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>游戏解构的基本框架</title>
    <link href="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>主要根据个人的学习情况记录一些游戏分析与解构的常用框架、关注重心和实际方法。仅代表个人观点，可能与他人观点或书本有出入。</p><span id="more"></span><h3 id="基本框架"><a href="#基本框架" class="headerlink" title="基本框架"></a>基本框架</h3><p>这里首先需要明确框架的意义，其主要目的是通过提供偏范式化的思维体系帮助游戏设计师更全面而细致的观察、分析或是构建一款游戏，切勿陷入完全的教条主义，使用时需同时结合思维体系和实践经验对游戏无论是优秀或是缺陷的设计进行更深入的认知。</p><p>常见的游戏分析框架有三种：MDA、FDD和四元法，每种框架都有各自的侧重点。</p><h4 id="MDA"><a href="#MDA" class="headerlink" title="MDA"></a>MDA</h4><p><strong>MDA</strong>即机制（Mechanics）、动态（Dynamics）、美学（Aesthetics），于2004年的游戏学论文《MDA：游戏设计的和研究的形式方法》中正式提出，主要强调设计师应首先关注游戏的美学，其次再处理动态和机制。</p><p>使用MDA框架的重点在于如何认知包含的机制、动态、美学三大元素。它们的标准化定义如下：</p><p><strong>机制</strong>：游戏数据层面的组件、算法和逻辑</p><p><strong>动态</strong>：玩家行为与游戏系统之间的互动反馈</p><p><strong>美学</strong>：玩家交互时产生的体验与情感。</p><p>说简洁点，机制、动态、美学分别代表工程，互动和体验。这里容易产生的一个误区是，美术、音效、音乐等资源更适合归类于动态范畴而否美学，美学的描述对象应是更抽象更主观的玩家体验。</p><p>举一个实际的案例，奥日与萤火意志，机制描述内容包括精灵碎片系统、精灵之光系统、技能系统、移动系统、场景构建、BOSS战设计、追逐战设计等；动态可以描述为“通过精灵之光解锁新技能”、“通过猛击反弹敌人攻击”、“利用精灵冲击探索地图收集碎片”等；美学的描述可能会更加主观：“通过孤立无援的情况下与豪尔的战斗营造紧张感与沮丧感”、“通过收集种子修缮家园让玩家感到自豪与成就”、“通过连续无落地的猛击关卡使玩家保持持续的专注”等。</p><p>大致理解上述描述后再思考MDA关系图，如下所示。</p><p><img src="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/1.jpg" alt="蜂蜜浏览器_33738CF9C90006C121C9BEC394CBBEC1"></p><p>我们发现MDA实际上是鼓励设计师从玩家的角度出发，将玩家的体验向底层描述归纳为动态和机制，在从机制出发，反向递推出设计师想要构建的体验。这是很常见也是习惯性的设计思路，也抓住了游戏的核心目的：创造玩家的体验。但是MDA作为一个早期的分析思路也存在一些问题。</p><p><strong>首先，MDA的基本假设之一从机制推导到玩家体验，这一过程存在很大的混沌性。</strong>这个问题的本质源于以客观理论描述主观体验的难度，以客述主的困难也是客观存在的，但从我找到的资料中，MDA并给出一些指导性方案帮助设计师推理。</p><p><strong>其次，MDA框架忽略了游戏设计的实现。</strong>游戏是一个复杂的系统，它同时具有商品、工程和艺术品的性质，MDA将业务逻辑过于抽象的封装在“机制”元素中，缺乏对游戏工程性质的描述。使用MDA解构游戏时可能问题不大，但将MDA用在设计游戏时思路容易受到限制。</p><p><strong>最后，MDA缺乏对体验界定性描述。</strong>MDA理论的文章中，很大程度强调了玩家体验的重要性，却没有对玩家体验进行深入的研究和分类，例如空洞骑士和奥日2，同样是Metroivania作品，但两者强调的体验中心却有很大区别，空洞希望玩家专注于用简单的攻击解决多样的问题，例如利用骨钉攻击造成的回弹辅助位移，而奥日则强调的是同一类问题使用多样化的解决思路，例如利用气泡、猛击或者三级跳符文推进探索。因此，两者强调的体验是完全不同的，玩空洞骑士时，玩家需要更仔细观察BOSS的攻击，突出攻击的节奏；而奥日等多样化的选择，需要玩家熟知个技能的性质，突出攻击的策略。这两种体验如果不去复盘其实很容易混淆，在设计时如果陷入这类误区很容易让游戏的体验低于预期。因此，游戏设计师一定需要有清晰的体验界定能力，而这一点MDA并没有提供多大帮助。</p><p>这些问题也可以理解为MDA的特点或者是优势，<strong>工程忽略性</strong>使其在解构难以复现的大型3A游戏时更加精简，<strong>体验界定和推导的不确定性</strong>也使后来的游戏设计师有更多的理论研究空间。</p><h3 id="FDD"><a href="#FDD" class="headerlink" title="FDD"></a>FDD</h3><p><strong>FDD</strong> 即形式（Formal）、戏剧（Dramatic）、动态（Dynamic Elements），最早从《游戏设计梦工厂》中提出，是更对设计师或学生具有指导意义的分析工具。学习的过程中发现网络上FDD的相关资料实在少得可怜，唯一系统的描述书《游戏设计梦工厂》还没有开读，所以理解十分有限，会在读到《游梦》的时候在再进行更正和修改，这里先从其他游戏设计书籍的复述和网络资料记录下现在浅显的理解。</p><p>对于认知有限的结构首先要做一定是<strong>同类比较</strong>，对比MDA的精简，FDD的三大元素的内容就细致很多：形式元素包括玩家交互模式、目标、规则、过程、资源、边界、结局；戏剧元素包括前提、角色、戏剧；动态元素包括涌现、涌现叙事、试玩。整体来看，这类细致的结构化思维意图很明显，就是能够知道实际的设计开发工作。三大元素下的细节之间的联系虽然不密切，但是都是在提出实际的问题，类似于《游戏设计艺术》中提到的<strong>透镜思维</strong>，透镜就是一系列的自我提问，Jesse Schell希望设计师能在实际开发中经常性的提问反思。实际上，我认为<strong>自问自答是解决实际设计项目基本也是核心方法</strong>。</p><p>简单来看一下FDD的三大元素分别强调了什么。</p><p><strong>形式元素</strong>在时间上强调了游戏目标、流程、结局，在空间上强调了游戏资源、边界，在规则上强调了限制、交互。实际上我这样的归类比较牵强，每个子元素之间的交叉实际很多，例如结局就可能通过包括时间和空间上的终点。但是我们能发现再这样的归类下，<strong>形式元素描述的是游戏的实际表现</strong>，因此设计师可以通过这一系列透镜<strong>复现一款优质游戏的玩法</strong>，从而判断<strong>此类玩法是否适合于其他的场景</strong>。</p><p><strong>戏剧元素</strong>全部描述的文案类的思路，其提到的前提（即世界观）、角色、情节是构成优秀游戏剧本不可或缺的部分，为游戏的剧情分析提供了三个维度。当然这三点一般能容易想到，但戏剧元素强调了<strong>利用剧情帮助玩家理解规则</strong>，例如武士零通过时间类药物解释为什么主角能够频繁读档但是记忆是连续的。因此戏剧元素是在帮助设计师<strong>复现文案的同时与游戏规则有所联系</strong>。</p><p><strong>动态元素</strong>是我理解比较懵的，它没有想MDA中的美学一样脱离游戏关注玩家体验，而是希望设计师去<strong>解释规则与体验间的作用关系</strong>，作者称之为<strong>涌现</strong>，这要求设计对玩家体验有清晰认知同时能够理解游戏规则的内涵。作者也为理解涌现提供了一个方法，充分的试玩和重复测试，说白了就是爆肝。</p><h3 id="四元法"><a href="#四元法" class="headerlink" title="四元法"></a>四元法</h3><p><strong>四元法</strong>即美学、机制、剧情、技术四大元素，Jesse Schell在其《游戏设计艺术》中提出。四元法是本文三类分析框架中实用性最高的（个人观点），常见的游戏行业传统职位都能够根据四元法进行归类（排除技术美术这类交叉职能）。例如概念设计师、原画师、建模师关注美学部分，主策划、系统策划、关卡策划、数值策划主要关注机制部分，文案策划关注剧情部分，客户端工程师、图形工程师、架构工程师关注技术部分。</p><p>此外，四元法分别根据玩家和设计建立一种思维方式，其核心关系如下图。</p><p><img src="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/2.jpg" alt="FDC75F852F7E7972670C41BF68D789D8"></p><p>于<strong>玩家</strong>而言，他们优先关注的是游戏的美学部分，其次是机制和剧情，最后才有一小部分群体会去关注技术（例如一些MOD作者、新设计师），但是于<strong>设计师</strong>而言，这四大元素是<strong>同样重要</strong>的，技术支撑了上层了机制与交互剧情的实现，最后以不同的美学形式展现。四元法和MDA一样同样考虑了玩家与设计师的角度。</p><p>想要更好理解四元法的四大元素，我们需要先理解《游戏设计艺术》一书的结构（然而只是因为我看了说得出来，个人感觉这本书最有用的都是目录前的架构图和一系列透镜了），在描述到游戏元素时Jesse的思维结构如下。</p><p><img src="/2020/02/17/%E6%B8%B8%E6%88%8F%E8%A7%A3%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95/3.jpg" alt="E600E86826260FB697BBF239F69DC58A"></p><p>一句话概括：<strong>游戏设计师本质的工作式设计玩家的体验，体验受限于场景，而游戏作为载体由元素构成并服务于特定主题。</strong>重中之重的是<strong>这四大元素是否都在为同一主题而努力</strong>，例如死亡搁浅，所有的游戏元素都是为了阐述“连接”这一主题，从机制上解锁开罗尔网络和送快递，故事上连接USC和冥滩，美学上BT的“尾巴”和冥滩与生界渗透场景，甚至技术上通过实现“共同基建”的机制将玩家们隐秘的连接起来。因此<strong>四元法的根本目标是服务游戏主题，而主题本质上又是服务于体验。</strong></p><p>基于上述想法我们同样以Jesse的透镜思维来简单理解这四大元素，不细致阐述（因为真的是太多了）。</p><p><strong>机制：</strong>玩家的目标是什么？这一目标服务于什么体验？玩家需要受限于什么规则？规则是否能起到加强玩家游戏理解或是强化体验的作用？玩家这一阶段需要受到什么反馈？这样的反馈能否使玩家保持在心流之中？机制描述了游戏基本运行逻辑，但仍需要下层技术提供实现，并通过上层美学反馈。</p><p><strong>故事：</strong>游戏的故事是要线性的还是碎片化的？这对玩家的游戏体验会造成什么差异？是否会阻碍游戏理解？剧情架构会对玩家的关注点产什么影响？故事同样需要下层技术提供实现，由上层美学反馈。</p><p><strong>美学：</strong>游戏的视觉效果、音效、音乐目的是营造什么体验？如何使用游戏美学让玩家保持沉浸？如何在正确的时机强调游戏美学展现出最大的影响力？美学对玩家体验有直接影响，关键要思考<strong>展现什么？什么时候展现/强调？</strong></p><p><strong>技术：</strong>技术要素比较独特，其本质是一种媒介，<em>美学通过它展现，机制通过它作用，故事通过它讲述</em>，既然是媒介而其根本目的又是服务体验，那最重要的就是<strong>合适</strong>的技术。但需要强调的是，现有的技术实际上服务于未来的游戏，因此技术是否合适还需要从时间发展角度去思考。</p><p>这是我认为四元法需要抓住的核心理解：在四元法的大体的思维架构下，需要同相应的<strong>透镜</strong>，也就是问题，在游戏设计的流程中时刻反思。当然四元法也包含很多实际设计的指导细节，但限于篇幅不予赘述（主要是太多说不明白），如有兴趣可以自读《游戏设计艺术》。</p><p>这里还需要提一下分层四元法，由Jeremy Gibson在《游戏设计、原型与开发：基于Unity与C#从构思 到实现》一书中提出（Unity的部分很老了，建议优先设计部分）。他将四元法分在了内嵌层、动态层 和文化层，对游戏设计的整体思路做出了更多的拓展，实际上分层四元法和Jesse目录的思维导图有很 多相似点，都是从脱离游戏本身而对游戏对玩家、设计师、社群甚至社会的影响进行了拓展。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>MDA</strong>展示了玩家与设计师对于游戏不同的思维方式与价值取向，强调设计师应通过玩家视角更完整有 效的审视自己的作品，着重强调了美学，即玩家的游玩体验。<br><strong>FDD</strong>对游戏设计的细节进行了归类并提出了指导性建议，为设计师和学生提供了实质性的帮助，着重强 调了叙事对玩家体验的作用，即叙事涌现。<br><strong>四元法</strong>实际偏向设计师角度去看待游戏，对游戏的元素进行了细致的分类，并提供了学多细节作为指导 性建议，着重强调了游戏-主题-体验的统一。</p>]]></content>
    
    
    <categories>
      
      <category>games</category>
      
    </categories>
    
    
    <tags>
      
      <tag>game design</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>小吹一波死亡搁浅</title>
    <link href="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/"/>
    <url>/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>死亡搁浅是小岛秀夫在离职科纳美之后的第一部作品。小岛秀夫作品个人风格明显：大段的过场CG，惊艳的镜头和光影设计，隐晦而深刻的主题，其之前合金装备。寂静岭等作品都因此而广受好评。死亡搁浅是我关注时间最久的作品之一，现通关之后借短暂回味的时间记录下一些想法。</p><p><img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/1A543B87E3DC9E601D4569DF6C76D00D.jpg" alt="1A543B87E3DC9E601D4569DF6C76D00D"></p><span id="more"></span><h1 id="分层四元法"><a href="#分层四元法" class="headerlink" title="分层四元法"></a>分层四元法</h1><p>Jesse Schell在《游戏设计艺术》一书中提出四元法，即游戏的四个基本元素：机制，美学，剧情，技术。之后Jeremy Gibson在其书《游戏、设计原型与开发》中对四元法、MDA、FDD进行了结合与拓展，提出了在四大元素的基础上将游戏分为内嵌层、动态层、文化层的分层四元法。分层四元法的游戏分析框架作为一个帮助理解游戏的工具，它也能帮助我们定义游戏内外的意义。</p><h1 id="内嵌层"><a href="#内嵌层" class="headerlink" title="内嵌层"></a>内嵌层</h1><p>内嵌层仅仅描述了游戏层面，从最底层、最基础的视角去分析游戏，而更少考虑互动性质和文化性质。</p><h2 id="PART1"><a href="#PART1" class="headerlink" title="PART1"></a>PART1</h2><h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>  《死亡搁浅》中玩家扮演送货员山姆，其主要目标就是送快递。在一个开放地图中，玩家需要从特定结点领取包裹，并尽可能快速、安全、完整的送到目标节点。长期来看，游戏的目标是要将美国从东部节点到西部节点通过送快递的方式重新连接起来。</p><p><img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/DA4909E584D37F9D0F0EFEB3027AF2B0.jpg" alt="DA4909E584D37F9D0F0EFEB3027AF2B0" style="zoom:67%;"></p><p>  摒弃了ACT传统的战斗玩法，而是原本最无趣的“跑路”作为主要玩法，这是导致《死亡搁浅》难以被定义的一项原因。这种目标设计的一个问题就是难以多样化的玩法，因此许多游戏会将跑路作为辅助要素（《消逝的光芒》《刺客信条》）或者是在做种强调心流（《风之旅人》）和快节奏的流畅体验（《镜之边缘》），但《死亡搁浅》更注重的是路线的优化。</p><h3 id="玩家关系"><a href="#玩家关系" class="headerlink" title="玩家关系"></a>玩家关系</h3><p><img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/6E1693EC2F6555E9AD769FBF2B942CD4.png" alt="6E1693EC2F6555E9AD769FBF2B942CD4"></p><p>  《死亡搁浅》的玩家关系是一大创新点，玩家在开放地图上建立的设施，会有几率被分配其他玩家的地图并提供帮助，并且有些设施是需要玩家共同建造的，例如公路、桥梁、安全屋。这种机制的本质是合作，但相比传统合作中即时、明确的反馈，其制造了一种更大的不确定性。这种合作机制和《死亡搁浅》主题——连接，有密切的关系。</p><p>  《死亡搁浅》的合作机制有一个很相似的原型。《史丹利的寓言》的作者Davey在他的一个视频中提到过他一个朋友做的游戏Demo，Demo中玩家能在地图中看到许多其他玩家的留言，Davey表示他很喜欢这种玩家间不确定连接的微妙感觉，但遗憾的是他朋友没能实现这个功能，这个有趣的点子最后只是一堆本地数据的模拟，这位朋友最终也在屡屡受挫之后彻底退出了游戏开发界。当然这已经是12年的事了。</p><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p><img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/F1B0E6EC1CE045AB4B21388A73CC3FEC.jpg" alt="F1B0E6EC1CE045AB4B21388A73CC3FEC"></p><p>  《死亡搁浅》提供了一个很有趣的边界设定——背包问题。游戏中携带物品都质量、重心和物理碰撞体积的设定，质量过可能导致步伐缓慢，重心过高可能导致转向时摔倒，而物理碰撞体积是货物损坏的根本原因。这种多参数影响下的背包问题，是《死亡搁浅》作为“快递模拟器”的核心机制，同时转化出了游戏的一个重要子目标：携带物品的最优化。</p><p>  另外一个边界就是路线问题，不同陡峭程度和不同类型的地形会对玩家送货造成不同程度的影响。非常精妙的是游戏中的每一个系统都能一定程度的优化路线，包括天气预报、网络覆盖，高度观测、路线标记等。假设玩家能够将所有系统的信息都充分利用起来，《死亡搁浅》其实可以看做带有混沌系统的ACT视角策略游戏，从策略游戏的视角来看《死亡搁浅》的话，那么这部作品的确具有开创意义。</p><p>《死亡搁浅》将单线程RTS游戏特性引入了ACT游戏（当然我个人认为当初设计的时候并没有刻意这么做）同样引出了一个问题——难以层次化的反馈。你的决策并不会得到明显的奖励和惩罚，优秀决策的结果只是成果送货和一些枯燥的数字评分，而糟糕的决策也只会导致一些无伤大雅的货箱损坏率或者重新开始任务。玩家在游戏中的决策多样，但是结果的区别却没有得到涌现。</p><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p><img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/71AB25C18167BAC03B6FB6D46937AC08.jpg" alt="71AB25C18167BAC03B6FB6D46937AC08"></p><p>  《死亡搁浅》原始的地图的设计可以说是优秀得普通，在其他玩家设施的帮助下所有任务都能在不用任何功能物品的情况下完成（亲测），地图流畅度良好。令人惊叹的是共享设施的分布，送货路线中共享设施的出现位置大多十分自然，玩家总是能借此找出一条流畅但又不至于过于简单的线路。</p><p>  这样不突兀的设施分布不会是随机的，而是和地图的抽象结构建模有密切关系（地形颜色 绿、蓝、黄、红），某个强大的生成算法作用下最终达到了这种路线流畅的效果。</p><p>  此外，将建筑原子化后随机分布的设计其实非常有意思。我们都知道Roguelike游戏最大的趣味之一是随机化的地图（《死亡细胞》《以撒的结合》），3D游戏采用这种策略则会导致极大的渲染代价。但如果转变一种思维呢？地图保持不变，反而对地图内所有的可互动要素做随机呢？</p><h2 id="PART2-美学"><a href="#PART2-美学" class="headerlink" title="PART2 美学"></a>PART2 美学</h2><h3 id="视觉"><a href="#视觉" class="headerlink" title="视觉"></a>视觉</h3><p>  《死亡搁浅》是一场视觉盛宴，其画面精美程度绝对是业界顶尖。</p><p>  《死亡搁浅》的视觉设计也完美体现了小岛强烈的个人风格——不想做电影的游戏制作人不是一个好的设计师。游戏的颜色主体低对比度的暗冷色调为主，能够恰到好处地烘托死亡搁浅后的末世氛围。</p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208143725779.png" alt="image-20191208143725779"></p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208143750155.png" alt="image-20191208143750155"></p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208143824991.png" alt="image-20191208143824991"></p><p>  《死亡搁浅》的CG表现可以说是十分优秀，小岛常用镜头手法是代入身份的隐变。虽然镜头全程是以第三方观测者为视角，但其变化混淆了第一人称和第三人称的界限。</p><p>  以心人剧情的开场CG为例，玩家在观察完心人的房间后，镜头切回主角山姆，再缓慢移动到心人的身体和全息仪表，此时的镜头可以代表山姆的视角，山姆与玩家同为观察主体。</p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208141225790.png" alt="image-20191208141225790"></p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208141312392.png" alt="image-20191208141312392"></p><p>  由于上一个镜头已经交代山姆的焦点在心人，在下一步复活的场景中没有进一步描述的必要，故将镜头移到心人侧面特写后旋转运镜到正面特写（山姆显然看不到正面特写），此时主要视觉呈现对象是玩家而非山姆。之后画面突然终止，转黑并显示章节名，镜头结束。在复活的镜头中我们同样可以看到主色彩的变化，又昏暗的蓝紫光转变为自然的白光，象征HEARTMAN从死亡状态到存活状态的转变。</p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208141412759.png" alt="image-20191208141412759"></p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208141451011.png" alt="image-20191208141451011"></p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208141714253.png" alt="image-20191208141714253"></p><p>  在设计针对玩家的视觉效果的时候，小岛最喜欢采用的就是面部特写，而演员的表演也十分惊艳。</p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208142509205.png" alt="image-20191208142509205"></p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208143050709.png" alt="image-20191208143050709"></p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/image-20191208143152743.png" alt="image-20191208143152743"></p><p>  此外《死亡搁浅》同样也继承了小岛风格的一项典例：频繁的转场动画，这导致游玩体验流畅度下降。</p><h3 id="听觉"><a href="#听觉" class="headerlink" title="听觉"></a>听觉</h3><p>  《死亡搁浅》拥有年度最强大的soundtrack，每一首歌曲都能恰到好处地契合游戏氛围。很可惜的是玩家并不能在送货过程中自定义歌曲播放，需要到雨亭、私人套间或特殊剧情区域才能够触发。《死亡搁浅》优秀音乐作为游戏一大亮点，却不能在乏味的跑路过程让玩家自定义播放，这点着实让人迷惑。</p><h3 id="触觉"><a href="#触觉" class="headerlink" title="触觉"></a>触觉</h3><p>  游戏中主角身体失衡反馈到手柄的震动有不小的区分度，我借此可以变成一个没有感情（和视觉的）的跑图机器，甚至游戏后期大部分路段能够闭着眼睛过去，当然这一块并不是重点。</p><h2 id="PART3-叙事"><a href="#PART3-叙事" class="headerlink" title="PART3 叙事"></a>PART3 叙事</h2><h3 id="设定"><a href="#设定" class="headerlink" title="设定"></a>设定</h3><p>《死亡搁浅》的世界里，人类死后灵魂被搁浅在冥滩而没有去到死者的世界，尸体出现了一种叫开罗尔的黑色物质，在开罗尔物质的作用下，被搁浅在冥滩的灵魂以BT的形式重新渗透进入了生者的世界，当生者被BT吞噬后会触发巨大的虚爆，就像反物质和物质的湮灭一般。虚爆将世界摧毁得支离玻碎，但开罗尔物质带来物质却不知如此，大量的开罗尔物质聚集成的云产生的雨水，会使其所接触所有物体的时间快速流逝，幸存的人类从地表撤离转入地下城，人类之间的联系被彻底隔断。</p><p>  《死亡搁浅》世界观设定很优秀，其核心主题连接能够在其世界观下得到多样的解释。</p><ol><li><p>生者与死者的连接</p></li><li><p>生者与生者的连接</p></li><li><p>抗争和命运的连接</p></li></ol><h3 id="情节"><a href="#情节" class="headerlink" title="情节"></a>情节</h3><p>三条线索：</p><ol><li><p>连接UCA，解救AMELIE。 </p><p>主要人物：AMELIE, HIGGS, FRAGILE, DIE-HARDMAN</p></li><li><p>研究死亡搁浅、冥滩和开罗尔物质</p><p>主要人物：HEARTMAN, MAMA</p></li><li><p>BB的来源</p><p>主要人物：CLIFF, DEADMAN</p><p>展开思路很好，但节奏存在一些问题，前三章情节缺少有效的推进，中期从和DEADMAN洗澡那段开始反转从而缓慢推进，最后三章则疯狂反转甩剧情。不熟悉套路的玩家或非核心粉丝大多会因为这种诡异的节奏早早弃坑。</p></li></ol><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>  《死亡搁浅》的角色设计非常棒，甚至剧情的推进都是以角色名为章节。（剧透预警）</p><p>  <img src="/2019/12/08/%E8%AE%B0%E4%B8%80%E6%AC%A1%E3%80%8A%E6%AD%BB%E4%BA%A1%E6%90%81%E6%B5%85%E3%80%8B%E7%9A%84%E8%A7%A3%E6%9E%84/4D180ADAD0499E054598628B64D32BA6.jpg" alt="img"></p><p><strong>SAM</strong></p><blockquote><p>Lou?</p></blockquote><p>玩家控制的游戏主角，是一个能够死后从冥滩返回生界的遣返者，同样也是能够感知BT的灭绝因子杜姆斯的携带者。在他特殊能力的帮助下他成为了死亡搁浅后一名送货员。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530003816344.jpg" alt="test image size" style="zoom:33%;"></p><p><strong>CLIFF</strong></p><blockquote><p>My bridge to the future.</p></blockquote><p>《死亡搁浅》中CLIFF贯穿了整个游戏最长的一条暗线，分别在游戏的三个不同阶段占据了三个章节。这个角色在游戏中作用巨大，他的出现引出了山姆的身世，BB、冥滩、开罗尔物质设定的相关细节，并提供游戏三个出彩的BOSS战。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530003908778.jpg" alt="img" style="zoom:33%;"></p><p><strong>AMELIE</strong></p><blockquote><p>Ame is a French for soul, A soul that’s lie.</p></blockquote><p>AMELIE是《死亡搁浅》的核心人物，是SAM同意帮助连接开罗尔网络的动机，她在第一次远征过程中遭到恐怖分子攻击，受困于西部结点等待救援。但实际上她是一个灭绝体，意味着她必须一直在冥滩等待正确的时机制造一次虚空爆炸灭绝人类，但在意识到自己的使命后，她却不堪在冥滩忍受数千年，于是在一次偶然的错误后，她决定将灭绝提前。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530011902367.jpg" alt="img" style="zoom:33%;"></p><p><strong>MAMA</strong></p><blockquote><p>Take me home. To Lockne.</p></blockquote><p>MAMA在游戏中被设定为第一批尝试连接UCA的远征队成员是开罗尔网络的设计师。剧情中MAMA的故事引出了开罗尔密度和冥滩、BT、死亡搁浅现象的关系，并且是后续解决死亡搁浅现象的关键。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530003834583.jpg" alt="img" style="zoom:33%;"></p><p><strong>DIE-HARDMAN</strong></p><blockquote><p>There is no atoning for what I’ve done.</p></blockquote><p>DIE-HARDMAN是山姆远征的总指挥官。游戏中用于指引玩家接受订单，剧情中……感觉只是为了剧情合理化和衬托CLIFF的工具人。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530005409436.jpg" alt="img" style="zoom:33%;"></p><p><strong>HEARTMAN</strong></p><blockquote><p>Two hundred and eighteen thousand five hundred and forty-nine times</p></blockquote><p>HEARTMAN同样是第一远征队成员，并且是一名冥滩科学家。剧情中他最终找出了死亡搁浅发生原因。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530003840479.jpg" alt="img" style="zoom:33%;"></p><p><strong>DEADMAN</strong></p><blockquote><p>I’m a Frankenstein monster.</p></blockquote><p>DEADMAN是一名BB科学家，一个人造人，在剧情前中期起到了为数不多的推进作用。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/19053000391457.jpg" alt="img" style="zoom:33%;"></p><p><strong>FRAGILE</strong></p><blockquote><p>I’m Fragile, but not that fragile.</p></blockquote><p>FRAGILE在游戏中使结点传送合理化，前中期她与HIGGS的矛盾是剧情一大推动力。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530003854421.jpg" alt="img" style="zoom:33%;"></p><p><strong>HIGGS</strong></p><blockquote><p>I’m the God particle everywhere</p></blockquote><p>HIGGS是占据西部结点的恐怖分子头领，在死亡搁浅的剧情中是前中期的核心反派，表面上他很吊但实际上也是工具人。</p><p><img src="https://img01.vgtime.com/game/cover/2019/05/30/190530003829399.jpg" alt="img" style="zoom:33%;"></p><p>​      </p><p>  小岛工作室官方曾经对《死亡搁浅》中人物的受欢迎程度做过一个榜单，个人更喜欢CLIFF、MAMA、HEARTMAN者三个角色，因为在《死亡搁浅》世界观里他们都是小人物，CLIFF是被政府利用后失去妻女的退役特种士兵，MAMA和HEARTMAN分别是是失去与妹妹联系和失去家人的科学家。死亡搁浅摧毁了他们重要的联系，他们都变成了某种意义上的搁浅物，却仍在不断同与命运抗争。相反地，《死亡搁浅》HIGGS，FRAGILE，DIE-HARDMAN这三个角色的塑造相对羸弱许多。</p>]]></content>
    
    
    <categories>
      
      <category>games</category>
      
    </categories>
    
    
    <tags>
      
      <tag>games</tag>
      
      <tag>death stranding</tag>
      
      <tag>kojima</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CTF题解记录</title>
    <link href="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/"/>
    <url>/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<p>记录打比赛时期做的一些web练习题</p><p>因为框架变复杂了，没有记录后几周的内容，但思路差不多。</p><span id="more"></span><h1 id="WEEK-1"><a href="#WEEK-1" class="headerlink" title="WEEK 1"></a>WEEK 1</h1><h2 id="加了报错的注入"><a href="#加了报错的注入" class="headerlink" title="加了报错的注入"></a>加了报错的注入</h2><blockquote><p>实验吧：<a href="http://ctf5.shiyanbar.com/web/baocuo/index.php">http://ctf5.shiyanbar.com/web/baocuo/index.php</a></p></blockquote><ol><li>查看页面源码，注释说明有sql注入<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/baocuo1.png" alt></li><li>然后测试一下username和password，发现有过滤<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/poc.png" alt></li><li>bp简单爆破一下过滤字符，得出结果：<br> username过滤了<code>(</code> <code>)</code> <code>=</code> <code>#</code>等字符以及<code>order by</code>等关键字, password过滤了<code>#</code> <code>=</code> <code>;</code> 等字符以及<code>updatexml()</code>和<code>ext()</code>两个报错函数。<br>  <img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/filter.png" alt></li><li>在伟大的搜索引擎的帮助下，我们查到了这两个报错函数的信息,顺便搜到了注入格式。<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/updatexml.png" alt></li><li>爆数据库测试一下可用<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/database.png" alt></li><li>然后爆表名，列名，flag，注意到<code>=</code>被过滤，换<code>LIKE</code>，结果<code>LIKE</code>也被过滤，于是换上了正则<code>regexp</code>,同样<code>show</code>也被过滤。<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/table.png" alt></li></ol><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">payload</span>:<span class="hljs-attribute">username</span>=<span class="hljs-number">1</span>&#x27; and updatexml/*&amp;password=*/(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">24</span>,(select database()),<span class="hljs-number">0</span>x<span class="hljs-number">24</span>),<span class="hljs-number">1</span>) and &#x27;<span class="hljs-number">1</span><span class="hljs-attribute">username</span>=<span class="hljs-number">1</span>&#x27; or updatexml/*&amp;password=*/(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">3</span>b,(select group_concat(table_name) from information_schema.tables where table_schema regexp database())),<span class="hljs-number">1</span>) and &#x27;<span class="hljs-number">1</span><span class="hljs-attribute">username</span>=<span class="hljs-number">1</span>&#x27; or updatexml/*&amp;password=*/(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">3</span>a,(select group_concat(column_name) from information_schema.columns where table_name regexp &#x27;ffll<span class="hljs-number">44</span>jj&#x27; )),<span class="hljs-number">1</span>) and &#x27;<span class="hljs-number">1</span><span class="hljs-attribute">username</span>=<span class="hljs-number">1</span>&#x27; or updatexml/*&amp;password=*/(<span class="hljs-number">1</span>,concat(<span class="hljs-number">0</span>x<span class="hljs-number">3</span>a,(select value from ffll<span class="hljs-number">44</span>jj)),<span class="hljs-number">1</span>) adn &#x27;<span class="hljs-number">1</span></code></pre></div><p>看了dalao的wp后发现password并没有过滤<code>exp()</code>函数可以直接利用<code>password</code>构造payload，不用分割注入。</p><blockquote><p>flag{err0r<em>b4sed_sqli</em>+_hpf}</p></blockquote><h2 id="上传绕过"><a href="#上传绕过" class="headerlink" title="上传绕过"></a>上传绕过</h2><blockquote><p>实验吧：<a href="http://ctf5.shiyanbar.com/web/upload/">http://ctf5.shiyanbar.com/web/upload/</a></p></blockquote><ol><li>这道题看上去是一个文件上传漏洞，查看源码，注意到了<code>hidden</code>表单，感觉有用。<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/hidden.png" alt></li><li>按要求传文件，报错要jpg，传jpg又报错要php，估计是有两次验证。<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/error3.png" alt><br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/error23.png" alt></li><li>直接字符截断没有用，想起那个表单，估计是要构造路径截断。</li><li>构造路径，进hex改包再发即可得flag！<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/hex.png" alt><blockquote><p>flag{SimCTF_huachuan}</p></blockquote></li></ol><h2 id="后台登录"><a href="#后台登录" class="headerlink" title="后台登录"></a>后台登录</h2><blockquote><p>实验吧：<a href="http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php">http://ctf5.shiyanbar.com/web/houtai/ffifdyop.php</a></p></blockquote><ol><li>源码有代码，估计是要构造md5注入。<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/hh.png" alt></li><li>怎么构造？</li><li>怎么构造？</li><li>怎么构造？</li><li>算了看wp吧</li><li>……</li><li>直接用文件名<code>ffifdyop</code>构造md5有了<code>&#39;or&#39;xxxx&#39;</code>的语句，注入成功，告辞。</li></ol><blockquote><p>flag{ffifdyop_has_trash}</p></blockquote><hr><h1 id="WEEK-2"><a href="#WEEK-2" class="headerlink" title="WEEK 2"></a>WEEK 2</h1><h2 id="1-没时间解释了"><a href="#1-没时间解释了" class="headerlink" title="1. 没时间解释了"></a>1. 没时间解释了</h2><blockquote><p>moctf: <a href="http://119.23.73.3:5006/web2/index2.php">http://119.23.73.3:5006/web2/index2.php</a></p><p>抓包阻止重定向-&gt;路径构造-&gt;时间竞争</p></blockquote><p>常规性的<code>F12</code>查看源码，并没有找到什么有用的信息，测试一波<code>.svn</code>和<code>.git</code>的源码泄露，仍然并没有什么有用的信息，遂放弃。</p><p>自闭一段时间后，观察到url<code>index2.php</code>觉得可能有问题，然后尝试访问<code>index.php</code>，重定向回了<code>index2.php</code>,于是改用BP截包，得到<code>index.php</code>返回如下：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/1-1.png" alt="uploadsomething"></p><p>访问<code>uploadsomething.php</code>，令人熟悉的表单映入眼帘，随意输入后显示:</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/1-2.png" alt></p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/1-3.png" alt></p><p>估计是一个路径构造，写了php一句话webshell并没有连上，试着访问了一下返回<code>Too Slow</code>，根据标题和该返回猜测是一个<strong>时间竞争</strong>，同时观察到不同提交返回的base64的路径是相同的，那么可以写脚本去构造路径并读取。<br>然而……</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/1-4.png" alt></p><p>脚本都是<code>Too Slow</code>！这不合理啊！后来用BP Intruder持续抓包，获得<code>flag</code>，至于脚本比BP慢这实在没有想到。</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/1-5.png" alt></p><h2 id="2-welcome-to-bugkuctf"><a href="#2-welcome-to-bugkuctf" class="headerlink" title="2. welcome to bugkuctf"></a>2. welcome to bugkuctf</h2><blockquote><p>bugkuctf: <a href="http://123.206.87.240:8006/test1/">http://123.206.87.240:8006/test1/</a></p><p>php协议-&gt;文件包含-&gt;php反序列化</p></blockquote><p>这道题小硬核。<br>常规<code>F12</code>得到源码：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-1.png" alt></p><p>尝试直接访问<code>hint.php</code>无果，注意到源码中文件包含函数<code>file_get_contents()</code>,<br>于是可以利用php协议操作数据流的方法，将字符串构造文件利用<code>php://input</code>上传<code>$user</code>，再利用<code>php://filter</code>获取返回的数据里，相关参考PHP官方文档：<a href="http://php.net/manual/zh/wrappers.php.php">http://php.net/manual/zh/wrappers.php.php</a> 。<br><code>php://filter</code>相关信息：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-1.5.png" alt></p><p>利用这个方法我们可以这样构造<code>payload</code>：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-1.9.png" alt></p><p>从而获得<code>index.php</code>和<code>hint.php</code>的源码<strong>base64</strong>:</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-2.5.png" alt></p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-3.5.png" alt></p><p>继续代码审计。</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-2.png" alt></p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-3.png" alt></p><p>观察得到这是一个php反序列化漏洞，利用在<code>hint.php</code>中得到的类名为<code>Flag</code>，使用的是<code>__toString</code>魔法函数，由此我们可以构造反序列化<code>payload</code>为<code>O:4:&quot;Flag&quot;:1:&#123;s:4:&quot;file&quot;;s:8:&quot;flag.php&quot;;&#125;</code>，<br>并得到<code>flag</code>：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/2-4.png" alt></p><h2 id="3-never-give-up"><a href="#3-never-give-up" class="headerlink" title="3. never give up"></a>3. never give up</h2><blockquote><p>bugkuctf: <a href="http://123.206.87.240:8006/test/hello.php">http://123.206.87.240:8006/test/hello.php</a></p><p>php任意文件读取-&gt;解码*3-&gt;字符截断</p></blockquote><p>这道题比较逗逼。<br>常规<code>F12</code>得到两行代码，带入注释里的<code>1p.html</code>发现重定向到了BugkuCTF的首页，于是Postman抓包得到如下结果：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-1.png" alt></p><p><strong>URL解码一把梭！</strong></p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-2.png" alt></p><p><strong>base64解码一把梭！</strong></p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-3.png" alt></p><p><strong>又是URL?一把梭！</strong></p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-4.png" alt></p><p>经过三次大起大落的编码转化，最后得到源码：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-5.png" alt></p><p>注意到代码中有两处矛盾：</p><ol><li><code>$id</code>即是<code>0</code>又不是<code>0</code></li><li><code>$b</code>的首位字符必须是<code>4</code>又不能是<code>4</code></li></ol><p>对于前者，采用php松散比较，利用<code>&#39;aaa&#39; == 0</code>的特性绕过，对于后者，采用字符截断（对于php版本的判断可以根据<code>$data</code>实现，这里已确定可截断）</p><p>那么！那么！那么！<br>就阔以构造粗配楼德<code>payload</code>:<br> <code>id=aaa&amp;a=php://input&amp;b=%00lutyhhh</code></p><p>得到<code>flag</code>：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-6.png" alt></p><p>似乎安排得明明白白…直到我看到其他大佬的wp…</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-7.png" alt></p><p>我的表情：</p><p><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/myface.jpg" alt></p><p>看来似出题人忘记屏蔽隔离了，不然这题也是小硬核。</p><h1 id="WEEK-3"><a href="#WEEK-3" class="headerlink" title="WEEK 3"></a>WEEK 3</h1><h2 id="Shrine"><a href="#Shrine" class="headerlink" title="Shrine"></a>Shrine</h2><blockquote><p>Tokyo Western CTF 2018<br>Link: <a href="https://github.com/CTFTraining/westerns_2018_shrine">https://github.com/CTFTraining/westerns_2018_shrine</a><br>Python模板注入 Python沙箱绕过 flask审计</p></blockquote><p>因为了解Python方面的审计去网上找到了这道CTF题目，这道题是用docker本地复现的，因为涉及到不会的知识点，所以到一半就照着WP继续了。</p><h3 id="1-代码审计"><a href="#1-代码审计" class="headerlink" title="1. 代码审计"></a>1. 代码审计</h3><p>这道题目非常直接，进入就是代码，在调整格式后我们可以得到源码如下:<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-1-1.png" alt></p><p>从源码可知：</p><ol><li>设定了两个路由，一个路由读取文件源码，另一个路由读进一个字符串对象。</li><li>第二个路由中读进的字符串，经过了函数<code>safe_jinja</code>的过滤，过滤函数删除了<code>(</code>和<code>)</code>并强行将<code>config</code>和<code>self</code>字符设为空。</li></ol><p>这时候思路已经比较明确了，要么读<code>config[&#39;FLAG&#39;]</code>要么读<code>os.envrion.pop(&#39;FLAG&#39;)</code>，但因<code>(</code> <code>)</code>被过滤第二个显然不行，<code>config</code>和<code>self</code>都被强制置空，那么就只能想别的方法，然而我没有想到。</p><h3 id="SSTI"><a href="#SSTI" class="headerlink" title="SSTI"></a>SSTI</h3><p>继续分析元源码，程序利用模板向后端传入了变量，因此存在模板注入(SSTI),我们可以简单构造一个Poc验证：<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-1-2.png" alt></p><p>在这里现补充模板的相关知识，模板用于将服务端返还内容渲染成前端页面，为了分离前端代码和后端变量，模板中设定<code> {{ }}</code>包括的内容为后端变量，<code>{% %}</code> 包括的内容为逻辑语句。</p><p>相关模板类型的Poc可以参考下图：<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-1-3.png" alt></p><h3 id="沙箱逃逸"><a href="#沙箱逃逸" class="headerlink" title="沙箱逃逸"></a>沙箱逃逸</h3><p>之后参考了一个大佬的WP(<a href="http://shaobaobaoer.cn/archives/665/tokyo-westerns-ctf-2018-web-wp#shrine">tokyo-westerns-ctf-2018-web-wp</a>)<br>，学习到了一些骚炫的姿势，这里复现一下他的思路</p><ol><li>既然<code>config</code>和<code>self</code>都被置空了，那么只能用其他方法读取到这个全局变量，就需要参考Flask框架的文档，这里应用到了python沙箱逃逸的方法，就我理解这方法就是<strong>利用python对象之间的引用关系来调用被禁用的函数对象</strong>，文中提供了一个flask上下文本地变量<code>current_app</code>，使用方法<code>__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]</code>。,通过在尝试这个<code>payload</code>后的到以下结果:<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-1-4.png" alt></li></ol><p>显然不能直接访问<code>__globals__</code>全局变量，目测有WAF需要再次逃逸。</p><ol><li>文中又提供了两种方法：<code>get_flashed_messages</code>和<code>url_for</code>这两个函数添加了<code>current_app</code>的引用，于是构造：<code>url_for.__globals__[&#39;current_app&#39;].config[&#39;FLAG&#39;]</code><br>最后<code>payload</code>：<code>http://127.0.0.1:8081/shrine/&#123;&#123;url_for.__globals__['current_app'].config['FLAG']&#125;&#125;</code><br>获得flag：<br><img src="/2018/11/13/CTF%E9%A2%98%E8%A7%A3%E8%AE%B0%E5%BD%95-web%E7%AF%87/3-1-5.png" alt></li></ol><p>在沙箱逃逸这一块的还有很多问题，比如怎么查到各对象之间的引用关系，哪些对象在哪些作用域有效，这里只积累了一个思路，以后需要在挖掘。</p><p>PS:刚刚写完SSTI的内容，<code>hexo deploy</code>的时候报错，一查结果是前面模板的花括号导致了解析，妙啊妙啊。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf-web</tag>
      
      <tag>ctf</tag>
      
      <tag>writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scrapy豆瓣ADHD小组爬虫实例</title>
    <link href="/2018/10/26/Scrapy%E8%B1%86%E7%93%A3ADHD%E5%B0%8F%E7%BB%84%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/"/>
    <url>/2018/10/26/Scrapy%E8%B1%86%E7%93%A3ADHD%E5%B0%8F%E7%BB%84%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>让自己熟悉<code>数据资源获取</code>-&gt;<code>数据持久化并整理</code>-&gt;<code>数据可视化</code>的数据处理流程，顺便记录下Scrapy的框架的使用过程。<br><span id="more"></span></p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p><strong>数据获取及持久化：</strong>利用Scrapy爬取ADHD豆瓣小组的所有帖子的标题、作者、以及最后回复时间，保存在cvs文件中。</p><p><strong>数据处理：</strong>对每一个标题字符串过滤无意义词汇、分词、关键字提取，Kmeans近义词聚类，统计出现次数最多的10个关键词。</p><p><strong>数据可视化：</strong>使用Echarts自动生成前十关键词图表。</p><h2 id="Scrapy"><a href="#Scrapy" class="headerlink" title="Scrapy"></a>Scrapy</h2><h3 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h3><p><img src="/2018/10/26/Scrapy%E8%B1%86%E7%93%A3ADHD%E5%B0%8F%E7%BB%84%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/desc.png" alt="原理图"></p><blockquote><p>Scrapy 原理图</p></blockquote><p>这是所有Scrapy教程都会提到一张图，大部分爬虫也是基于这个逻辑，很简洁也很重要，其中：</p><p><code>Pipline</code>是数据管道，一般用来在做数据持久化或其他数据的后续处理</p><p><code>Spiders</code>是编写的爬虫，scrapy支持多爬虫异步运行。</p><p><code>Scheduler</code>维护了一个requests列表，爬虫将按照这个列表发出请求。</p><p><code>Downloader</code>可以从response获取链接并通过迭代使爬虫持续运行。</p><p><code>Middleware</code>可以使数据传输过程中执行一些特殊操作，例如在<code>Downloader Middleware</code>中可以使用selenium执行js代码。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><h4 id="adhdspider-py"><a href="#adhdspider-py" class="headerlink" title="adhdspider.py"></a>adhdspider.py</h4><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> scrapy<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> sys<span class="hljs-keyword">from</span> adhd.items <span class="hljs-keyword">import</span> AdhdItem<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">adhdspider</span>(<span class="hljs-params">scrapy.Spider</span>):</span>    name = <span class="hljs-string">&quot;adhd&quot;</span>    allowed_damains=[<span class="hljs-string">&#x27;https://www.douban.com/group&#x27;</span>]    start_urls = [        <span class="hljs-string">&quot;https://www.douban.com/group/ADD-ADHD/discussion?start=0&quot;</span>    ]    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">self, response</span>):</span>        item = AdhdItem()        selector = scrapy.Selector(response)        comment = selector.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/div[2]/table[@class=&quot;olt&quot;]&#x27;</span>)        title = comment.xpath(<span class="hljs-string">&#x27;//tr[*]/td[@class=&quot;title&quot;]/a/text()&#x27;</span>).extract()        author = comment.xpath(<span class="hljs-string">&#x27;//tr[*]/td[@nowrap=&quot;nowrap&quot;]/a/text()&#x27;</span>).extract()        time = comment.xpath(<span class="hljs-string">&#x27;//tr[*]/td[@class=&quot;time&quot;]/text()&#x27;</span>).extract()        <span class="hljs-comment">#print (len(title))</span>        <span class="hljs-comment">#print (len(author))</span>        <span class="hljs-comment">#print (len(time))</span>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(author)):            item[<span class="hljs-string">&#x27;title&#x27;</span>] = <span class="hljs-string">&quot;&quot;</span>.join(title[i].strip())            item[<span class="hljs-string">&#x27;author&#x27;</span>] = <span class="hljs-string">&quot;&quot;</span>.join(author[i].strip())            item[<span class="hljs-string">&#x27;time&#x27;</span>] = <span class="hljs-string">&quot;&quot;</span>.join(time[i].strip())            <span class="hljs-keyword">yield</span> item        <span class="hljs-keyword">try</span>:            next_page = response.xpath(<span class="hljs-string">&#x27;//*[@id=&quot;content&quot;]/div/div[1]/div[3]/span[@class=&quot;next&quot;]/a/@href&#x27;</span>).extract()[<span class="hljs-number">0</span>]            <span class="hljs-keyword">yield</span> scrapy.Request(next_page)        <span class="hljs-keyword">except</span>:            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;所有信息爬取完毕！&quot;</span>)            <span class="hljs-keyword">pass</span></code></pre></div><blockquote><ol><li>这里继承的不是CrawlSpider所以用Request抛出迭代，如果使用CrawlSpider可以通过设置rules和Linkextract来定义迭代规则。</li><li>抛出item是字符串，如果抛出列表会是cvs文件内容异常的丑 :(</li><li>chrome复制XPATH要把自渲染的tbody去掉！</li></ol></blockquote><h4 id="piplines-py"><a href="#piplines-py" class="headerlink" title="piplines.py"></a>piplines.py</h4><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> csv<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdhdPipeline_tocsv</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        catalog = os.path.dirname(__file__) + <span class="hljs-string">&#x27;/spiders/result.csv&#x27;</span>        self.file = <span class="hljs-built_in">open</span>(catalog,<span class="hljs-string">&#x27;w&#x27;</span>)        self.write = csv.writer(self.file)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">process_item</span>(<span class="hljs-params">self, item, spider</span>):</span>        <span class="hljs-keyword">if</span> item[<span class="hljs-string">&#x27;title&#x27;</span>]:            self.write.writerow((item[<span class="hljs-string">&#x27;title&#x27;</span>],item[<span class="hljs-string">&#x27;author&#x27;</span>],item[<span class="hljs-string">&#x27;time&#x27;</span>]))        <span class="hljs-keyword">return</span> item    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">close_spider</span>(<span class="hljs-params">self,spider</span>):</span>        self.file.close()</code></pre></div><h4 id="setting-py"><a href="#setting-py" class="headerlink" title="setting.py"></a>setting.py</h4><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span>BOT_NAME = <span class="hljs-string">&#x27;adhd&#x27;</span>SPIDER_MODULES = [<span class="hljs-string">&#x27;adhd.spiders&#x27;</span>]NEWSPIDER_MODULE = <span class="hljs-string">&#x27;adhd.spiders&#x27;</span>USER_AGENT = <span class="hljs-string">&#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.67 Safari/537.36&#x27;</span>ROBOTSTXT_OBEY = <span class="hljs-literal">True</span>FEED_URI = <span class="hljs-string">&#x27;file:///home/luty/桌面/result.csv&#x27;</span>FEED_FORMAT = <span class="hljs-string">&#x27;CSV&#x27;</span>ITEM_PIPELINES = &#123;    <span class="hljs-string">&#x27;adhd.pipelines.AdhdPipeline_tocsv&#x27;</span>: <span class="hljs-number">300</span>,&#125;</code></pre></div><h4 id="items-py"><a href="#items-py" class="headerlink" title="items.py"></a>items.py</h4><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> scrapy<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdhdItem</span>(<span class="hljs-params">scrapy.Item</span>):</span>    title=scrapy.Field()    author=scrapy.Field()    time=scrapy.Field()    <span class="hljs-keyword">pass</span></code></pre></div><h4 id="run-py"><a href="#run-py" class="headerlink" title="run.py"></a>run.py</h4><h2 id><a href="#" class="headerlink" title></a><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">from</span> scrapy <span class="hljs-keyword">import</span> cmdlinecmdline.execute(<span class="hljs-string">&quot;scrap crawl adhd&quot;</span>.split())</code></pre></div></h2><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><img src="/2018/10/26/Scrapy%E8%B1%86%E7%93%A3ADHD%E5%B0%8F%E7%BB%84%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/result.png" alt="运行结果"></p><h2 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><blockquote><ol><li>使用jieba库进行了简单的分词和关键词提取</li><li>设定一个字典dict.txt来设置一些专业名词，例如专注达、择思达等</li></ol></blockquote><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><span class="hljs-keyword">import</span> csv<span class="hljs-keyword">import</span> re<span class="hljs-keyword">import</span> jieba<span class="hljs-keyword">import</span> jieba.analyse<span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter jieba.load_userdict(<span class="hljs-string">&#x27;/home/luty/桌面/dict.txt&#x27;</span>)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/home/luty/桌面/result.csv&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> csvfile:    reader = csv.reader(csvfile)    column = [row[<span class="hljs-number">2</span>] <span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> reader]    <span class="hljs-built_in">list</span>=[]<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> column:    <span class="hljs-keyword">if</span>(i!=<span class="hljs-string">&#x27;title&#x27;</span>):    <span class="hljs-comment">#利用正则库去除标点</span>        temp=re.sub(<span class="hljs-string">&quot;[\s+\.\!\/_,$%^*(+\&quot;\&#x27;]+|[+——！，。？、~@#￥%……&amp;*（）]+&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,i)        result = jieba.analyse.extract_tags(temp, topK=<span class="hljs-number">20</span>)        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> result:            <span class="hljs-built_in">list</span>.append(j)            <span class="hljs-comment">#print(j)</span><span class="hljs-comment">#print(list)</span>dic=Counter(<span class="hljs-built_in">list</span>)<span class="hljs-keyword">for</span> key,vaule <span class="hljs-keyword">in</span> dic.items():<span class="hljs-built_in">print</span>(key)<span class="hljs-built_in">print</span>(vaule)</code></pre></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p><img src="/2018/10/26/Scrapy%E8%B1%86%E7%93%A3ADHD%E5%B0%8F%E7%BB%84%E7%88%AC%E8%99%AB%E5%AE%9E%E4%BE%8B/result2.png" alt="运行结果"></p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>等待添加…</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://scrapy-chs.readthedocs.io/zh_CN/0.24/intro/tutorial.html">Scrapy官方文档</a></p><p><a href="https://github.com/fxsjy/jieba/">jieba仓库</a></p>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅谈注入攻击及小结</title>
    <link href="/2018/08/08/%E6%B5%85%E8%B0%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%8F%8A%E5%B0%8F%E7%BB%93/"/>
    <url>/2018/08/08/%E6%B5%85%E8%B0%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%8F%8A%E5%B0%8F%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>最近科三考试临近，疲惫的练车时光就要结束了，彩六也是打到手软才突然想起要学习，决定挤出了点时间研究下sql inject，在这里做下记录和小结。</p><p><img src="/2018/08/08/%E6%B5%85%E8%B0%88%E6%B3%A8%E5%85%A5%E6%94%BB%E5%87%BB%E5%8F%8A%E5%B0%8F%E7%BB%93/2.jpg" alt="疲惫"><br><span id="more"></span></p><h2 id="什么是注入？"><a href="#什么是注入？" class="headerlink" title="什么是注入？"></a>什么是注入？</h2><p>注入(inject)攻击产生的本质原因是输入过滤机制的不完善，导致攻击者可以利用输入数据构造执行代码，从而造成信息泄露、数据损坏、服务宕机等一系列问题。由于注入(inject)攻击常常导致严重后果，进一步催生了`<strong>一切输入有害</strong>的重要安全思想。</p><h2 id="注入如何产生？"><a href="#注入如何产生？" class="headerlink" title="注入如何产生？"></a>注入如何产生？</h2><p>个人认为注入攻击产生的本质是：当一段输入数据需要添加到另一端执行指令或代码中时，攻击者可以根据指令或代码的语法刻意构造一段输入数据，造成的输入数据作为指令执行的错误。</p><p>例如在PHP + MySQL平台下：<br><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-meta">&lt;?php</span> <span class="hljs-variable">$name</span> = <span class="hljs-variable">$_POST</span>[<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-variable">$con</span> = mysqli_connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;test&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-keyword">die</span>(<span class="hljs-string">&quot;error&quot;</span>);<span class="hljs-variable">$query</span> = <span class="hljs-string">&quot;SELECT * FROM person WHERE name=&#x27;<span class="hljs-subst">$name</span>&#x27;;&quot;</span>;<span class="hljs-variable">$result</span> = mysqli_query(<span class="hljs-variable">$con</span>,<span class="hljs-variable">$query</span>);<span class="hljs-keyword">while</span>(<span class="hljs-variable">$row</span>=mysqli_fetch_assoc(<span class="hljs-variable">$result</span>))<span class="hljs-keyword">echo</span> <span class="hljs-variable">$row</span>[<span class="hljs-string">&#x27;age&#x27;</span>];​```这是一个用户通过输入name从person表查询对应age的场景，但是代码中没有对输入变量<span class="hljs-variable">$name</span>进行任何检测和过滤，如果我们构造<span class="hljs-variable">$name</span>为`<span class="hljs-number">1</span><span class="hljs-string">&#x27;or&#x27;</span><span class="hljs-number">1</span><span class="hljs-string">&#x27;=&#x27;</span><span class="hljs-number">1</span>`，那么查询语句<span class="hljs-variable">$query</span>就会变成：`<span class="hljs-string">&quot;SELECT * FROM person WHERE name=&#x27;1&#x27; or &#x27;1&#x27;=&#x27;1&#x27;;&quot;</span>`，然而该查询语句恒成立，意味着这样的输入将会爆出数据库person表中所有人的age，造成信息泄露。在上面这个案例中，如果我们对<span class="hljs-variable">$name</span>或者<span class="hljs-variable">$query</span>进行过滤，比如将`<span class="hljs-string">&#x27;`和`&quot;`转义，或者字符处理掉`=`，那么上面构造的输入数据不会被执行。这只是一个最简单的案例，想了解和实践更多可以部署[DVWA](http://www.dvwa.co.uk/)进行本地或者远程测试。</span><span class="hljs-string">## SQL注入</span><span class="hljs-string">根据是否有直接反馈信息分为 普通注入 和 盲注，盲注往往要利用`sleep()`时间盲注或者利用`ascii()`进行布尔盲注。</span><span class="hljs-string"></span><span class="hljs-string">大概流程是这样的：</span><span class="hljs-string">1.注入POC</span><span class="hljs-string">2.猜字段数</span><span class="hljs-string">3.猜字段顺序</span><span class="hljs-string">4.爆数据库名</span><span class="hljs-string">5.爆表名</span><span class="hljs-string">6.爆字段</span><span class="hljs-string">7.脱裤</span><span class="hljs-string"></span><span class="hljs-string">有些步骤根据实际情况可有可无的，爆库过程中需要用到`information_schema`，在这里我就不XJB说了，具体参考：</span><span class="hljs-string">[DVWA-1.9全级别教程之SQL Injection](http://www.freebuf.com/articles/web/120747.html)</span><span class="hljs-string">[DVWA-1.9全级别教程之SQL Injection(Blind)](http://www.freebuf.com/articles/web/120985.html)</span><span class="hljs-string">## SQL注入绕过</span><span class="hljs-string">我参考文章做了一些本地测试，记录了一些可能常用的绕过方法，环境为lamp，以下就算是是笔记了，一开简单记录，后面有时间会细化。</span><span class="hljs-string">1. 空格：`/**/` `%a0` `()`</span><span class="hljs-string">2. `&#x27;</span>`引号：`hex()` `urlencode()`<span class="hljs-number">3</span>. `=`等号：`like` `rlike` `regexp`<span class="hljs-number">4</span>. `&lt;&gt;`比较符：`greatest()` `least()` `strcmp()` `in` `between`<span class="hljs-number">5</span>. `,`逗号：`substr()`和`mid()`用`<span class="hljs-keyword">from</span> to`代替，`limit`用`offset`<span class="hljs-number">6</span>. 其他绕过： 大小写、字符嵌套、内联注释等还有一个没看懂的先mark：[一些报错注入](https:<span class="hljs-comment">//blog.csdn.net/airuozhaoyang/article/details/47036923)</span>**宽字节注入**：这个注入方式比较特殊，有两个产生条件。- 涉及到gbk编码 (iconv等含有编码转化功能的函数)- 涉及到转义`\`(魔术引号、addslashes、htmlspecialchars)原理大概是，正常字符为<span class="hljs-number">2</span>字节，汉字字符为<span class="hljs-number">4</span>字节，在gbk的编码环境下可以`%df\`这样的字符，应为`\`的编码是`%<span class="hljs-number">5</span>c`，结合起来为`%df%<span class="hljs-number">5</span>c`，解码结果为汉字`運`，从而绕过了`\`的转义消毒。**注：gbk2312应不存在低位范围无法进行宽字节注入，具体参考[这里](http:<span class="hljs-comment">//www.bubuko.com/infodetail-2100074.html)。**</span>后续会慢慢添加实例帮助理解和实践。参考:[SQL注入绕过技巧](https:<span class="hljs-comment">//www.cnblogs.com/Vinson404/p/7253255.html)</span>[sql关键词绕过【积累中】](https:<span class="hljs-comment">//blog.csdn.net/wy_97/article/details/78085664)</span><span class="hljs-comment">## 小结</span>无论是XSS、sqli还是commandi，只要有输入数据添加到指令的场景，就有注入攻击发生的风险，开发者也在努力寻找通用性解决方案。PHP和python中不正确的使用`system()` `exec()`等函数会导致命令注入，前段不对js代码进行过滤会导致XSS，windows平台还有dll注入（不明觉厉），感觉都很刺激啊。PHP5.<span class="hljs-number">4</span>后使用的PDO技术和Mysqli几乎已经杜绝了sql注入，其他平台的防御策略也越来越完善，所以sql在实际渗透环境中可能作用并不大，但是这种思想还是很有意思的。![我也很绝望啊](./<span class="hljs-number">1</span>.jpg)吐槽几句，贵阳这天气是魔鬼吗，阳光直射出门半小时后大暴雨，学车能遇到军事行动，四妹又在发情期，真是每天都有新乐趣hhhh</code></pre></div></p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>sqli</tag>
      
      <tag>commandi</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TensorFlow快进到入坟</title>
    <link href="/2018/05/25/TensorFlow%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/"/>
    <url>/2018/05/25/TensorFlow%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9D%9F/</url>
    
    <content type="html"><![CDATA[<p>记录对这个框架的基本理解，一些重要的API和一些工程实践。</p><span id="more"></span><h2 id="三个核心："><a href="#三个核心：" class="headerlink" title="三个核心："></a>三个核心：</h2><ol><li>所有的数据都是张量</li><li>所有计算都是计算图</li><li>执行运算和管理资源都要使用会话</li></ol><h2 id="一些基本运行原理："><a href="#一些基本运行原理：" class="headerlink" title="一些基本运行原理："></a>一些基本运行原理：</h2><p>Tensorflow的所有计算都在计算图（Graph）中运行，通过集合（Collection）管理资源（变量、张量、队列资源），其中TensorFlow维护了一个tf.GraphKeys.VARIABLES的集合，该集合包含了所有的变量。</p><p>例如<code>a = tf.constan([1.0,2.0],name=&quot;a&quot;)</code>中，<code>tf.constant</code>是一个计算，计算的结果是一个<code>Tensor</code>，每一个<code>Tensor</code>都有三个属性：</p><ol><li>名字（name），作为张量的唯一标识符。</li><li>维度（shape），描述张量的维度信息，例如<code>shape=(3,3,1)</code>表示该张量有三个维度（可以理解为多维数组），各个维度长度分别为<code>3</code>,<code>3</code>,<code>1</code>，采用<code>None</code>则表示该维度不定长。</li><li>类型（type），数据类型，同其他编程语言。</li></ol><p>logits:  一个事件发生与该事件不发生的比值的对数</p><h2 id="note"><a href="#note" class="headerlink" title="note"></a>note</h2><div class="hljs code-wrapper"><pre><code class="hljs python">numpy.squeeze(a, axis=<span class="hljs-literal">None</span>)squeeze()函数的功能是：从矩阵shape中，去掉维度为<span class="hljs-number">1</span>的。例如一个矩阵是的shape是（<span class="hljs-number">5</span>， <span class="hljs-number">1</span>），使用过这个函数后，结果为（<span class="hljs-number">5</span>，）。参数： a是输入的矩阵 axis : 选择shape中的一维条目的子集。如果在shape大于<span class="hljs-number">1</span>的情况下设置axis，则会引发错误。tf.gfile.Glob(filename)Defined <span class="hljs-keyword">in</span> tensorflow/python/lib/io/file_io.py.Returns a <span class="hljs-built_in">list</span> of files that match the given pattern(s).       图：一些Tensor和Operation的集合    实际上，Tensorflow而是首先将 python 代码所描绘的图转换（即“序列化”）成 Protocol Buffer，再通过 C/C++/CUDA 运行 Protocol Buffer 所定义的图。</code></pre></div><h2 id="基础又重要的内容"><a href="#基础又重要的内容" class="headerlink" title="基础又重要的内容"></a>基础又重要的内容</h2><h3 id="1-Part-1"><a href="#1-Part-1" class="headerlink" title="1. Part 1"></a>1. Part 1</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#计算图和会话的基本使用</span>g1 = tf.graph()<span class="hljs-keyword">with</span> g1.as_default():    <span class="hljs-keyword">pass</span><span class="hljs-comment">#your operation</span>g2 = tf.graph()<span class="hljs-keyword">with</span> g1.as_default():    <span class="hljs-keyword">pass</span><span class="hljs-comment">#your operation</span><span class="hljs-keyword">with</span> tf.Session(graph=g1) <span class="hljs-keyword">as</span> sess:    tf.initializer_all_variables().run()    <span class="hljs-comment">#your operation</span>    <span class="hljs-comment">#定义一个常向量</span>a = tf.constant([<span class="hljs-number">1.0</span>,<span class="hljs-number">2.0</span>],name=<span class="hljs-string">&quot;a&quot;</span>)<span class="hljs-comment">#定义矩阵乘法</span>x1 = tf.matmul(x,w1)<span class="hljs-comment">#定义一个一维变向量，初始化为0, 计算图中张量的初始化需要使用`initializer`</span>v = tf.get_variable(name=<span class="hljs-string">&quot;v&quot;</span>,initializer=tf.zeros_initializer(shape=[<span class="hljs-number">1</span>]))<span class="hljs-comment">#定义一个随机矩阵变量，标准差为2，注意get_variable不会处理命名冲突，Varaible则会，因此在需要共享变量名的场景下应采用get_variable</span>a = tf.Variable(tf.random_normal([<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],stddev=<span class="hljs-number">2</span>))<span class="hljs-comment">#assign用于给变量赋值</span>tf.assign(w1,w2)<span class="hljs-comment">#定义了一个placeholder数据入口</span>x = tf.placeholder(<span class="hljs-built_in">type</span>=tf.float32, shape=(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>), name=<span class="hljs-string">&quot;x-input&quot;</span>)<span class="hljs-comment">#定义了反向传播算法和梯度下降优化器</span>train_step = tf.train.GradientDescentOptimizer(learning_rate).minimizer(cross_entropy)</code></pre></div><h3 id="2-Part-2"><a href="#2-Part-2" class="headerlink" title="2. Part 2"></a>2. Part 2</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment">#tf.reduce_mean 函数用于计算张量tensor某个维度上的的平均值，tf.clip_by_value可以吧数据限制在一个范围之内</span><span class="hljs-comment">#例中利用_y张量计算了平均交叉熵。</span>cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y,<span class="hljs-number">1e-10</span>,<span class="hljs-number">1.0</span>)))<span class="hljs-comment">#定义了一个使用softmax回归的交叉熵损失函数</span>cross_entropy = tf.nn.softmax_cross_entropy_with_logits(y,y_)<span class="hljs-comment">#定义了一个均方差的损失函数</span>mse = tf.reduce_mean(tf.square(_y-y))<span class="hljs-comment">#tf.reduce_sum压缩求和，tf.select当参数一条件为真时，会使用参数二的值，否则会使用参数三的值，tf.greater会逐个比较张量中每个元素的大小</span><span class="hljs-comment">#以下代码实现了一个简单的自定义损失函数</span>loss = tf.reduce_sum(tf.select(tf.greater(v1,v2),(v1-v2)*a,(v2-v1)*b)<span class="hljs-comment">#利用tf.contrib.layers.12_regularizer()对原均方差损失函数进行了正则化，lambda表示正则化权重，w为正则化损失参数</span>loss = tf.reduce_mean(tf.square(y_ - y)) + tf.contrib.layers<span class="hljs-number">.12</span>_regularizer(<span class="hljs-keyword">lambda</span>)(w)                     <span class="hljs-comment">#以下代码中利用add_yo_colection将正则化损失项加入到losses集合中</span> tf.add_to_collection(<span class="hljs-string">&#x27;losses&#x27;</span>,tf.contrib.layers<span class="hljs-number">.12</span>_regularizer(<span class="hljs-keyword">lambda</span>)(w))                     <span class="hljs-comment">#以下代码定义了一个滑动平均类ema，并定义了滑动平均操作maintain_averages_op，其中decay_rate衰减率，越接近1模型越稳定，step是控制衰减率的变量。</span>ema = tf.train.ExponentialMovingAverage(decay_rate,step)maintain_averages_op = ema.apply([v1])</code></pre></div><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="1-简单前馈神经网络"><a href="#1-简单前馈神经网络" class="headerlink" title="1. 简单前馈神经网络"></a>1. 简单前馈神经网络</h3><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*-coding:utf-8 -*-</span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> numpy.random <span class="hljs-keyword">import</span> RandomStatebatch_size = <span class="hljs-number">8</span>w1= tf.Variable(tf.random_normal([<span class="hljs-number">2</span>, <span class="hljs-number">3</span>], stddev=<span class="hljs-number">1</span>, seed=<span class="hljs-number">1</span>))w2= tf.Variable(tf.random_normal([<span class="hljs-number">3</span>, <span class="hljs-number">1</span>], stddev=<span class="hljs-number">1</span>, seed=<span class="hljs-number">1</span>))x = tf.placeholder(tf.float32, shape=(<span class="hljs-literal">None</span>, <span class="hljs-number">2</span>), name=<span class="hljs-string">&quot;x-input&quot;</span>)y_= tf.placeholder(tf.float32, shape=(<span class="hljs-literal">None</span>, <span class="hljs-number">1</span>), name=<span class="hljs-string">&#x27;y-input&#x27;</span>)a = tf.matmul(x, w1)y = tf.matmul(a, w2)cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, <span class="hljs-number">1e-10</span>, <span class="hljs-number">1.0</span>))) train_step = tf.train.AdamOptimizer(<span class="hljs-number">0.001</span>).minimize(cross_entropy)rdm = RandomState(<span class="hljs-number">1</span>)X = rdm.rand(<span class="hljs-number">128</span>,<span class="hljs-number">2</span>)a = tf.matmul(x, w1)y = tf.matmul(a, w2)cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, <span class="hljs-number">1e-10</span>, <span class="hljs-number">1.0</span>))) train_step = tf.train.AdamOptimizer(<span class="hljs-number">0.001</span>).minimize(cross_entropy)Y = [[<span class="hljs-built_in">int</span>(x1+x2 &lt; <span class="hljs-number">1</span>)] <span class="hljs-keyword">for</span> (x1, x2) <span class="hljs-keyword">in</span> X]<span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:    init_op = tf.global_variables_initializer()    sess.run(init_op)            STEPS = <span class="hljs-number">5000</span>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(STEPS):        start = (i*batch_size) % <span class="hljs-number">128</span>        end = (i*batch_size) % <span class="hljs-number">128</span> + batch_size        sess.run(train_step, feed_dict=&#123;x: X[start:end], y_: Y[start:end]&#125;)        <span class="hljs-keyword">if</span> i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>:            total_cross_entropy = sess.run(cross_entropy, feed_dict=&#123;x: X, y_: Y&#125;)            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After %d training step(s), cross entropy on all data is %g&quot;</span> % (i, total_cross_entropy))        <span class="hljs-comment"># 输出训练后的参数取值。</span>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;\n&quot;</span>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;w1:&quot;</span>, sess.run(w1)    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;w2:&quot;</span>, sess.run(w2)</code></pre></div><h3 id="2-MNIST手写数据集-CNN版"><a href="#2-MNIST手写数据集-CNN版" class="headerlink" title="2. MNIST手写数据集 - CNN版"></a>2. MNIST手写数据集 - CNN版</h3><p><strong>定义前向传播流程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*-coding:utf-8-*-</span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tfINPUT_NODE = <span class="hljs-number">784</span>    <span class="hljs-comment">#输入的节点数 28*28</span>OUTPUT_NODE = <span class="hljs-number">10</span>    <span class="hljs-comment">#输出的节点数 10</span>IMAGE_SIZE = <span class="hljs-number">28</span>     <span class="hljs-comment">#图像大小</span>NUM_CHANNELS = <span class="hljs-number">1</span>    <span class="hljs-comment">#图像深度</span>NUM_LABELS = <span class="hljs-number">10</span>     <span class="hljs-comment">#数字种类</span>CONV1_DEEP = <span class="hljs-number">32</span>     <span class="hljs-comment">#第一层卷积层深度</span>CONV1_SIZE = <span class="hljs-number">5</span>      <span class="hljs-comment">#第一层卷积层尺寸</span>CONV2_DEEP = <span class="hljs-number">64</span>     <span class="hljs-comment">#第二层卷积层深度</span>CONV2_SIZE = <span class="hljs-number">5</span>      <span class="hljs-comment">#第二层卷积层尺寸</span>FC_SIZE = <span class="hljs-number">512</span>       <span class="hljs-comment">#全连接层的节点个数</span><span class="hljs-comment">#定义CNN前向传播的过程</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inference</span>(<span class="hljs-params">input_tensor, train, regularizer</span>):</span><span class="hljs-comment">#卷积层1</span>    <span class="hljs-keyword">with</span> tf.variable_scope(<span class="hljs-string">&#x27;layer1-conv1&#x27;</span>):        conv1_weights = tf.get_variable(            <span class="hljs-string">&quot;weight&quot;</span>, [CONV1_SIZE, CONV1_SIZE, NUM_CHANNELS, CONV1_DEEP],            initializer=tf.truncated_normal_initializer(stddev=<span class="hljs-number">0.1</span>))        conv1_biases = tf.get_variable(<span class="hljs-string">&quot;bias&quot;</span>, [CONV1_DEEP], initializer=tf.constant_initializer(<span class="hljs-number">0.0</span>))        conv1 = tf.nn.conv2d(input_tensor, conv1_weights, strides=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">&#x27;SAME&#x27;</span>)        relu1 = tf.nn.relu(tf.nn.bias_add(conv1, conv1_biases))    <span class="hljs-comment">#池化层1</span>    <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">&quot;layer2-pool1&quot;</span>):        pool1 = tf.nn.max_pool(relu1, ksize = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],strides=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>],padding=<span class="hljs-string">&quot;SAME&quot;</span>)    <span class="hljs-comment">#卷积层2</span>    <span class="hljs-keyword">with</span> tf.variable_scope(<span class="hljs-string">&quot;layer3-conv2&quot;</span>):        conv2_weights = tf.get_variable(            <span class="hljs-string">&quot;weight&quot;</span>, [CONV2_SIZE, CONV2_SIZE, CONV1_DEEP, CONV2_DEEP],            initializer=tf.truncated_normal_initializer(stddev=<span class="hljs-number">0.1</span>))        conv2_biases = tf.get_variable(<span class="hljs-string">&quot;bias&quot;</span>, [CONV2_DEEP], initializer=tf.constant_initializer(<span class="hljs-number">0.0</span>))        conv2 = tf.nn.conv2d(pool1, conv2_weights, strides=[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">&#x27;SAME&#x27;</span>)        relu2 = tf.nn.relu(tf.nn.bias_add(conv2, conv2_biases))    <span class="hljs-comment">#池化层2</span>    <span class="hljs-keyword">with</span> tf.name_scope(<span class="hljs-string">&quot;layer4-pool2&quot;</span>):        pool2 = tf.nn.max_pool(relu2, ksize=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], strides=[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>], padding=<span class="hljs-string">&#x27;SAME&#x27;</span>)        pool_shape = pool2.get_shape().as_list()        nodes = pool_shape[<span class="hljs-number">1</span>] * pool_shape[<span class="hljs-number">2</span>] * pool_shape[<span class="hljs-number">3</span>]        reshaped = tf.reshape(pool2, [pool_shape[<span class="hljs-number">0</span>], nodes])    <span class="hljs-comment">#全连接层1</span>    <span class="hljs-keyword">with</span> tf.variable_scope(<span class="hljs-string">&#x27;layer5-fc1&#x27;</span>):        fc1_weights = tf.get_variable(<span class="hljs-string">&quot;weight&quot;</span>, [nodes, FC_SIZE],                                      initializer=tf.truncated_normal_initializer(stddev=<span class="hljs-number">0.1</span>))        <span class="hljs-keyword">if</span> regularizer != <span class="hljs-literal">None</span>: tf.add_to_collection(<span class="hljs-string">&#x27;losses&#x27;</span>, regularizer(fc1_weights))        fc1_biases = tf.get_variable(<span class="hljs-string">&quot;bias&quot;</span>, [FC_SIZE], initializer=tf.constant_initializer(<span class="hljs-number">0.1</span>))        fc1 = tf.nn.relu(tf.matmul(reshaped, fc1_weights) + fc1_biases)        <span class="hljs-keyword">if</span> train: fc1 = tf.nn.dropout(fc1, <span class="hljs-number">0.5</span>)            <span class="hljs-comment">#全连接层2</span>    <span class="hljs-keyword">with</span> tf.variable_scope(<span class="hljs-string">&#x27;layer6-fc2&#x27;</span>):        fc2_weights = tf.get_variable(<span class="hljs-string">&quot;weight&quot;</span>, [FC_SIZE, NUM_LABELS],                                      initializer=tf.truncated_normal_initializer(stddev=<span class="hljs-number">0.1</span>))        <span class="hljs-keyword">if</span> regularizer != <span class="hljs-literal">None</span>: tf.add_to_collection(<span class="hljs-string">&#x27;losses&#x27;</span>, regularizer(fc2_weights))        fc2_biases = tf.get_variable(<span class="hljs-string">&quot;bias&quot;</span>, [NUM_LABELS], initializer=tf.constant_initializer(<span class="hljs-number">0.1</span>))        logit = tf.matmul(fc1, fc2_weights) + fc2_biases    <span class="hljs-keyword">return</span> logit</code></pre></div><p><strong>定义训练流程</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># -*-coding:utf-8-*-</span><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data<span class="hljs-keyword">import</span> LeNet5_infernece<span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> npBATCH_SIZE = <span class="hljs-number">100</span>LEARNING_RATE_BASE = <span class="hljs-number">0.01</span>LEARNING_RATE_DECAY = <span class="hljs-number">0.99</span><span class="hljs-comment">#学习率衰减率</span>REGULARIZATION_RATE = <span class="hljs-number">0.0001</span><span class="hljs-comment">#正则化</span>TRAINING_STEPS = <span class="hljs-number">1000</span>   <span class="hljs-comment">#训练轮数</span>MOVING_AVERAGE_DECAY = <span class="hljs-number">0.99</span><span class="hljs-comment">#滑动平均模型的指数衰减率</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">mnist</span>):</span>    <span class="hljs-comment"># 定义输出为4维矩阵的placeholder</span>    x = tf.placeholder(tf.float32, [            BATCH_SIZE,            LeNet5_infernece.IMAGE_SIZE,            LeNet5_infernece.IMAGE_SIZE,            LeNet5_infernece.NUM_CHANNELS],        name=<span class="hljs-string">&#x27;x-input&#x27;</span>)    y_ = tf.placeholder(tf.float32, [<span class="hljs-literal">None</span>, LeNet5_infernece.OUTPUT_NODE], name=<span class="hljs-string">&#x27;y-input&#x27;</span>)        <span class="hljs-comment">#这里的L2 regularizer是正则器，用于全连接层</span>    regularizer = tf.contrib.layers.l2_regularizer(REGULARIZATION_RATE)    <span class="hljs-comment">#这里的y是训练后的答案</span>    y = LeNet5_infernece.inference(x,<span class="hljs-literal">False</span>,regularizer)    <span class="hljs-comment">#定义滑动平均模型的迭代</span>    global_step = tf.Variable(<span class="hljs-number">0</span>, trainable=<span class="hljs-literal">False</span>)    <span class="hljs-comment"># 定义滑动平均类</span>    variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step)    <span class="hljs-comment"># 定义滑动平均操作</span>    variables_averages_op = variable_averages.apply(tf.trainable_variables())    <span class="hljs-comment"># 定义交叉熵函数</span>    cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y, labels=tf.argmax(y_, <span class="hljs-number">1</span>))    <span class="hljs-comment"># 均值交叉熵函数</span>    cross_entropy_mean = tf.reduce_mean(cross_entropy)    <span class="hljs-comment"># 定义损失函数</span>    loss = cross_entropy_mean + tf.add_n(tf.get_collection(<span class="hljs-string">&#x27;losses&#x27;</span>))    <span class="hljs-comment"># 定义滑动平均下降的学习率</span>    learning_rate = tf.train.exponential_decay(        LEARNING_RATE_BASE,        global_step,        mnist.train.num_examples / BATCH_SIZE, LEARNING_RATE_DECAY,        staircase=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># 定义训练迭代器</span>    train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step)    <span class="hljs-comment"># 定义训练操作</span>    <span class="hljs-keyword">with</span> tf.control_dependencies([train_step, variables_averages_op]):        train_op = tf.no_op(name=<span class="hljs-string">&#x27;train&#x27;</span>)            <span class="hljs-comment"># 计算准确率</span>    correct_prediction = tf.equal(tf.argmax(y, <span class="hljs-number">1</span>), tf.argmax(y_, <span class="hljs-number">1</span>))    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))    keep_prob = tf.placeholder(tf.float32)    <span class="hljs-comment"># 初始化TensorFlow持久化类。</span>    saver = tf.train.Saver()    <span class="hljs-keyword">with</span> tf.Session() <span class="hljs-keyword">as</span> sess:        tf.global_variables_initializer().run()        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(TRAINING_STEPS):            xs, ys = mnist.train.next_batch(BATCH_SIZE)            reshaped_xs = np.reshape(xs, (                BATCH_SIZE,                LeNet5_infernece.IMAGE_SIZE,                LeNet5_infernece.IMAGE_SIZE,                LeNet5_infernece.NUM_CHANNELS))                        _, loss_value, step = sess.run([train_op, loss, global_step], feed_dict=&#123;x: reshaped_xs, y_: ys&#125;)            <span class="hljs-keyword">if</span> i % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:                train_accuracy = accuracy.<span class="hljs-built_in">eval</span>(feed_dict=&#123;x: reshaped_xs, y_: ys, keep_prob: <span class="hljs-number">1.0</span>&#125;)                <span class="hljs-comment">#print(&quot;After %d training step(s), loss on training batch is %g.&quot; % (step, loss_value))</span>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;The %d training accuracy is: %g&quot;</span> % (i,train_accuracy))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span>        <span class="hljs-keyword">pass</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">argv=<span class="hljs-literal">None</span></span>):</span>    mnist = input_data.read_data_sets(<span class="hljs-string">&quot;/Dataset/MNIST_data&quot;</span>, one_hot=<span class="hljs-literal">True</span>)    train(mnist)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre></div><h3 id="3-MNIST手写数据集-GAN版"><a href="#3-MNIST手写数据集-GAN版" class="headerlink" title="3. MNIST手写数据集 - GAN版"></a>3. MNIST手写数据集 - GAN版</h3><p><strong>这里挂的是别人的代码，自己的代码一直出问题没解决。</strong></p><p><strong>生成器和判断器同样采用简单的三层全连接网络。</strong></p><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf <span class="hljs-comment">#导入tensorflow</span><span class="hljs-keyword">from</span> tensorflow.examples.tutorials.mnist <span class="hljs-keyword">import</span> input_data <span class="hljs-comment">#导入手写数字数据集</span><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np <span class="hljs-comment">#导入numpy</span><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt <span class="hljs-comment">#plt是绘图工具，在训练过程中用于输出可视化结果</span><span class="hljs-keyword">import</span> matplotlib.gridspec <span class="hljs-keyword">as</span> gridspec <span class="hljs-comment">#gridspec是图片排列工具，在训练过程中用于输出可视化结果</span><span class="hljs-keyword">import</span> os <span class="hljs-comment">#导入os</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">xavier_init</span>(<span class="hljs-params">size</span>):</span> <span class="hljs-comment">#初始化参数时使用的xavier_init函数</span>    in_dim = size[<span class="hljs-number">0</span>]     xavier_stddev = <span class="hljs-number">1.</span> / tf.sqrt(in_dim / <span class="hljs-number">2.</span>) <span class="hljs-comment">#初始化标准差</span>    <span class="hljs-keyword">return</span> tf.random_normal(shape=size, stddev=xavier_stddev) <span class="hljs-comment">#返回初始化的结果</span> X = tf.placeholder(tf.float32, shape=[<span class="hljs-literal">None</span>, <span class="hljs-number">784</span>]) <span class="hljs-comment">#X表示真的样本(即真实的手写数字)</span> D_W1 = tf.Variable(xavier_init([<span class="hljs-number">784</span>, <span class="hljs-number">128</span>])) <span class="hljs-comment">#表示使用xavier方式初始化的判别器的D_W1参数，是一个784行128列的矩阵</span>D_b1 = tf.Variable(tf.zeros(shape=[<span class="hljs-number">128</span>])) <span class="hljs-comment">#表示全零方式初始化的判别器的D_1参数，是一个长度为128的向量</span> D_W2 = tf.Variable(xavier_init([<span class="hljs-number">128</span>, <span class="hljs-number">1</span>])) <span class="hljs-comment">#表示使用xavier方式初始化的判别器的D_W2参数，是一个128行1列的矩阵</span>D_b2 = tf.Variable(tf.zeros(shape=[<span class="hljs-number">1</span>])) <span class="hljs-comment">##表示全零方式初始化的判别器的D_1参数，是一个长度为1的向量</span> theta_D = [D_W1, D_W2, D_b1, D_b2] <span class="hljs-comment">#theta_D表示判别器的可训练参数集合</span>  Z = tf.placeholder(tf.float32, shape=[<span class="hljs-literal">None</span>, <span class="hljs-number">100</span>]) <span class="hljs-comment">#Z表示生成器的输入(在这里是噪声)，是一个N列100行的矩阵</span> G_W1 = tf.Variable(xavier_init([<span class="hljs-number">100</span>, <span class="hljs-number">128</span>])) <span class="hljs-comment">#表示使用xavier方式初始化的生成器的G_W1参数，是一个100行128列的矩阵</span>G_b1 = tf.Variable(tf.zeros(shape=[<span class="hljs-number">128</span>])) <span class="hljs-comment">#表示全零方式初始化的生成器的G_b1参数，是一个长度为128的向量</span> G_W2 = tf.Variable(xavier_init([<span class="hljs-number">128</span>, <span class="hljs-number">784</span>])) <span class="hljs-comment">#表示使用xavier方式初始化的生成器的G_W2参数，是一个128行784列的矩阵</span>G_b2 = tf.Variable(tf.zeros(shape=[<span class="hljs-number">784</span>])) <span class="hljs-comment">#表示全零方式初始化的生成器的G_b2参数，是一个长度为784的向量</span> theta_G = [G_W1, G_W2, G_b1, G_b2] <span class="hljs-comment">#theta_G表示生成器的可训练参数集合</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save</span>(<span class="hljs-params">saver, sess, logdir, step</span>):</span> <span class="hljs-comment">#保存模型的save函数</span>   model_name = <span class="hljs-string">&#x27;model&#x27;</span> <span class="hljs-comment">#模型名前缀</span>   checkpoint_path = os.path.join(logdir, model_name) <span class="hljs-comment">#保存路径</span>   saver.save(sess, checkpoint_path, global_step=step) <span class="hljs-comment">#保存模型</span>   <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;The checkpoint has been created.&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sample_Z</span>(<span class="hljs-params">m, n</span>):</span> <span class="hljs-comment">#生成维度为[m, n]的随机噪声作为生成器G的输入</span>    <span class="hljs-keyword">return</span> np.random.uniform(-<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, size=[m, n])  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generator</span>(<span class="hljs-params">z</span>):</span> <span class="hljs-comment">#生成器，z的维度为[N, 100]</span>    G_h1 = tf.nn.relu(tf.matmul(z, G_W1) + G_b1) <span class="hljs-comment">#输入的随机噪声乘以G_W1矩阵加上偏置G_b1，G_h1维度为[N, 128]</span>    G_log_prob = tf.matmul(G_h1, G_W2) + G_b2 <span class="hljs-comment">#G_h1乘以G_W2矩阵加上偏置G_b2，G_log_prob维度为[N, 784]</span>    G_prob = tf.nn.sigmoid(G_log_prob) <span class="hljs-comment">#G_log_prob经过一个sigmoid函数，G_prob维度为[N, 784]</span>     <span class="hljs-keyword">return</span> G_prob <span class="hljs-comment">#返回G_prob</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">discriminator</span>(<span class="hljs-params">x</span>):</span> <span class="hljs-comment">#判别器，x的维度为[N, 784]</span>    D_h1 = tf.nn.relu(tf.matmul(x, D_W1) + D_b1) <span class="hljs-comment">#输入乘以D_W1矩阵加上偏置D_b1，D_h1维度为[N, 128]</span>    D_logit = tf.matmul(D_h1, D_W2) + D_b2 <span class="hljs-comment">#D_h1乘以D_W2矩阵加上偏置D_b2，D_logit维度为[N, 1]</span>    D_prob = tf.nn.sigmoid(D_logit) <span class="hljs-comment">#D_logit经过一个sigmoid函数，D_prob维度为[N, 1]</span>     <span class="hljs-keyword">return</span> D_prob, D_logit <span class="hljs-comment">#返回D_prob, D_logit</span>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">plot</span>(<span class="hljs-params">samples</span>):</span> <span class="hljs-comment">#保存图片时使用的plot函数</span>    fig = plt.figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">#初始化一个4行4列包含16张子图像的图片</span>    gs = gridspec.GridSpec(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">#调整子图的位置</span>    gs.update(wspace=<span class="hljs-number">0.05</span>, hspace=<span class="hljs-number">0.05</span>) <span class="hljs-comment">#置子图间的间距</span>     <span class="hljs-keyword">for</span> i, sample <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(samples): <span class="hljs-comment">#依次将16张子图填充进需要保存的图像</span>        ax = plt.subplot(gs[i])        plt.axis(<span class="hljs-string">&#x27;off&#x27;</span>)        ax.set_xticklabels([])        ax.set_yticklabels([])        ax.set_aspect(<span class="hljs-string">&#x27;equal&#x27;</span>)        plt.imshow(sample.reshape(<span class="hljs-number">28</span>, <span class="hljs-number">28</span>), cmap=<span class="hljs-string">&#x27;Greys_r&#x27;</span>)     <span class="hljs-keyword">return</span> fig  G_sample = generator(Z) <span class="hljs-comment">#取得生成器的生成结果</span>D_real, D_logit_real = discriminator(X) <span class="hljs-comment">#取得判别器判别的真实手写数字的结果</span>D_fake, D_logit_fake = discriminator(G_sample) <span class="hljs-comment">#取得判别器判别的生成的手写数字的结果</span> D_loss_real = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=D_logit_real, labels=tf.ones_like(D_logit_real))) <span class="hljs-comment">#对判别器对真实样本的判别结果计算误差(将结果与1比较)</span>D_loss_fake = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=D_logit_fake, labels=tf.zeros_like(D_logit_fake))) <span class="hljs-comment">#对判别器对虚假样本(即生成器生成的手写数字)的判别结果计算误差(将结果与0比较)</span>D_loss = D_loss_real + D_loss_fake <span class="hljs-comment">#判别器的误差</span>G_loss = tf.reduce_mean(tf.nn.sigmoid_cross_entropy_with_logits(logits=D_logit_fake, labels=tf.ones_like(D_logit_fake))) <span class="hljs-comment">#生成器的误差(将判别器返回的对虚假样本的判别结果与1比较)</span> dreal_loss_sum = tf.summary.scalar(<span class="hljs-string">&quot;dreal_loss&quot;</span>, D_loss_real) <span class="hljs-comment">#记录判别器判别真实样本的误差</span>dfake_loss_sum = tf.summary.scalar(<span class="hljs-string">&quot;dfake_loss&quot;</span>, D_loss_fake) <span class="hljs-comment">#记录判别器判别虚假样本的误差</span>d_loss_sum = tf.summary.scalar(<span class="hljs-string">&quot;d_loss&quot;</span>, D_loss) <span class="hljs-comment">#记录判别器的误差</span>g_loss_sum = tf.summary.scalar(<span class="hljs-string">&quot;g_loss&quot;</span>, G_loss) <span class="hljs-comment">#记录生成器的误差</span> summary_writer = tf.summary.FileWriter(<span class="hljs-string">&#x27;snapshots/&#x27;</span>, graph=tf.get_default_graph()) <span class="hljs-comment">#日志记录器</span> D_solver = tf.train.AdamOptimizer().minimize(D_loss, var_list=theta_D) <span class="hljs-comment">#判别器的训练器</span>G_solver = tf.train.AdamOptimizer().minimize(G_loss, var_list=theta_G) <span class="hljs-comment">#生成器的训练器</span> mb_size = <span class="hljs-number">128</span> <span class="hljs-comment">#训练的batch_size</span>Z_dim = <span class="hljs-number">100</span> <span class="hljs-comment">#生成器输入的随机噪声的列的维度</span> mnist = input_data.read_data_sets(<span class="hljs-string">&#x27;../../MNIST_data&#x27;</span>, one_hot=<span class="hljs-literal">True</span>) <span class="hljs-comment">#mnist是手写数字数据集</span> sess = tf.Session() <span class="hljs-comment">#会话层</span>sess.run(tf.global_variables_initializer()) <span class="hljs-comment">#初始化所有可训练参数</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&#x27;out/&#x27;</span>): <span class="hljs-comment">#初始化训练过程中的可视化结果的输出文件夹</span>    os.makedirs(<span class="hljs-string">&#x27;out/&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(<span class="hljs-string">&#x27;snapshots/&#x27;</span>): <span class="hljs-comment">#初始化训练过程中的模型保存文件夹</span>    os.makedirs(<span class="hljs-string">&#x27;snapshots/&#x27;</span>) saver = tf.train.Saver(var_list=tf.global_variables(), max_to_keep=<span class="hljs-number">50</span>) <span class="hljs-comment">#模型的保存器</span> i = <span class="hljs-number">0</span> <span class="hljs-comment">#训练过程中保存的可视化结果的索引</span> <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100000</span>): <span class="hljs-comment">#训练100万次</span>    <span class="hljs-keyword">if</span> it % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>: <span class="hljs-comment">#每训练1000次就保存一下结果</span>        samples = sess.run(G_sample, feed_dict=&#123;Z: sample_Z(<span class="hljs-number">16</span>, Z_dim)&#125;)         fig = plot(samples) <span class="hljs-comment">#通过plot函数生成可视化结果</span>        plt.savefig(<span class="hljs-string">&#x27;out/&#123;&#125;.png&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">str</span>(i).zfill(<span class="hljs-number">3</span>)), bbox_inches=<span class="hljs-string">&#x27;tight&#x27;</span>) <span class="hljs-comment">#保存可视化结果</span>        i += <span class="hljs-number">1</span>        plt.close(fig)     X_mb, _ = mnist.train.next_batch(mb_size) <span class="hljs-comment">#得到训练一个batch所需的真实手写数字(作为判别器的输入)</span>     <span class="hljs-comment">#下面是得到训练一次的结果，通过sess来run出来</span>    _, D_loss_curr, dreal_loss_sum_value, dfake_loss_sum_value, d_loss_sum_value = sess.run([D_solver, D_loss, dreal_loss_sum, dfake_loss_sum, d_loss_sum], feed_dict=&#123;X: X_mb, Z: sample_Z(mb_size, Z_dim)&#125;)    _, G_loss_curr, g_loss_sum_value = sess.run([G_solver, G_loss, g_loss_sum], feed_dict=&#123;Z: sample_Z(mb_size, Z_dim)&#125;)     <span class="hljs-keyword">if</span> it%<span class="hljs-number">100</span> ==<span class="hljs-number">0</span>: <span class="hljs-comment">#每过100次记录一下日志，可以通过tensorboard查看</span>        summary_writer.add_summary(dreal_loss_sum_value, it)        summary_writer.add_summary(dfake_loss_sum_value, it)        summary_writer.add_summary(d_loss_sum_value, it)        summary_writer.add_summary(g_loss_sum_value, it)     <span class="hljs-keyword">if</span> it % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>: <span class="hljs-comment">#每训练1000次输出一下结果</span>        save(saver, sess, <span class="hljs-string">&#x27;snapshots/&#x27;</span>, it)        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Iter: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(it))        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;D loss: &#123;:.4&#125;&#x27;</span>. <span class="hljs-built_in">format</span>(D_loss_curr))        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;G_loss: &#123;:.4&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(G_loss_curr))        <span class="hljs-built_in">print</span>()        <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">--------------------- </span><span class="hljs-string">作者：jiongnima </span><span class="hljs-string">来源：CSDN </span><span class="hljs-string">原文：https://blog.csdn.net/jiongnima/article/details/80033169 </span><span class="hljs-string">&#x27;&#x27;&#x27;</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>machine learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
      <tag>tensorflow</tag>
      
      <tag>machinelearning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Hexo和Github快速搭建个人博客</title>
    <link href="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这篇文章为纯新手向，主要内容利用github平台快速建立并托管个人Hexo的Next网站，无论文科生和理科生，都能在一个小时左右完成部署，平台为windows。</p><blockquote><p>为阅读本文章，你需要同时阅读：<br><a href="https://hexo.io/zh-cn/docs/">Hexo官方文档</a><br><a href="https://theme-next.iissnan.com/getting-started.html">Next主题官方文档</a><br><a href="https://github.com/younghz/Markdown">Markdown语法参考</a></p><h2 id="Hexo-Github模式优点"><a href="#Hexo-Github模式优点" class="headerlink" title="Hexo + Github模式优点"></a>Hexo + Github模式优点</h2><ul><li>节省购置服务器的费用</li><li>快速搭建，快速部署</li><li>学习成本低，学习价值高<span id="more"></span><h2 id="主要步骤"><a href="#主要步骤" class="headerlink" title="主要步骤"></a>主要步骤</h2>一. 建立github仓库<br>二. 建立本地Hexo博客<br>三. 配置本地Hexo博客<br>四. 连接本地Hexo与gitpages</li></ul></blockquote><h2 id="开始搭建吧！"><a href="#开始搭建吧！" class="headerlink" title="开始搭建吧！"></a>开始搭建吧！</h2><h3 id="建立github仓库"><a href="#建立github仓库" class="headerlink" title="建立github仓库"></a>建立github仓库</h3><p>开始之前确保已注册github帐号并下载gitbash。<br>如果还没有，请参考：<a href="http://wiki.jikexueyuan.com/project/github-basics/sign-up.html">极客学院github初识教程</a>完成注册和下载。</p><blockquote><p>点击创建仓库</p></blockquote><p><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github1.png" alt="github1"></p><blockquote><p>如图输入仓库名，其中方框部分应与github用户名一致</p></blockquote><p><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/github2.png" alt="github2"></p><p><strong>强调：红色方框中的输入内容应为用户名，否则无法托管。</strong></p><h3 id="建立本地Hexo博客"><a href="#建立本地Hexo博客" class="headerlink" title="建立本地Hexo博客"></a>建立本地Hexo博客</h3><p>请先自主阅读<a href>Hexo官方文档-概述</a>，若按照官方文档已完成安装，可以跳过该步骤。</p><ol><li><p><strong>安装Node.js</strong><br>从<a href="https://nodejs.org/en/">Node.js官网</a>下载并安装Node.js环境，推荐LTS（Long-Term-Support）版本。</p></li><li><p><strong>本地下载Hexo</strong><br>首先选择你要配置本地博客的目录，右击选择 <strong>Git Bash Here</strong>，<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitbash.png" alt="gitbahs"><br>从而进入如图gitbash环境<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/gitbash_cli.png" alt="gitbash2"><br><strong>注意：明白这一步直很重要，之后所有命令都是在gitbash中完成！</strong></p></li><li><p><strong>安装hexo</strong><br>gitbash输入:<code>npm install -g hexo-cli</code>会开始安装Hexo，安装完成后会有如图所示目录文件。</p></li></ol><p>各目录的作用请参考：<a href>Hexo官方文档-建站</a></p><h3 id="配置本地Hexo博客"><a href="#配置本地Hexo博客" class="headerlink" title="配置本地Hexo博客"></a>配置本地Hexo博客</h3><p>请先自主阅读<a href="https://hexo.io/zh-cn/docs/configuration.html">Hexo官方文档-配置</a>与<a href="https://theme-next.iissnan.com/getting-started.html">NexT官网文档-开始使用</a>，若按照官方文档已完成部署，可以跳过该步骤。</p><ol><li><p><strong>下载并部署NexT主题</strong><br>前往<a href="https://github.com/iissnan/hexo-theme-next/releases">NexT版本发布页面</a>下载官方Source code.zip并解压，将解压后的文件名修改为<strong>next</strong>后置于你本地博客目录的themes文件夹。</p></li><li><p><strong>本地预览</strong><br>在博客目录下的gitbash中输入<br><code>hexo clean</code><br><code>hexo g</code><br>完成初始化，之后使用命令<br><code>hexo s</code><br>完成本地部署。<br>本地部署后可，通过访问<code>localhost:4000</code>从而访问本地博客。至此，你已经可以看到你的博客首页了。<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/预览.png" alt="预览"></p></li></ol><ol><li><p><strong>区别本地配置和主题配置</strong><br>两个配置文件均为<code>_config.yml</code>，但有本质区别，之后配置需注意不要混淆。<br><strong>本地配置</strong>：位于 本地博客根目录下<code>_config.yml</code><br><strong>主题配置</strong>：位于 本地博客目录/themes/主题目录(如next)下的<code>_config.yml</code></p></li><li><p><strong>配置本地配置</strong><br>打开本地配置的<code>_config.yml</code>，找到如图Themes字段：<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/theme.png" alt="theme"><br>将字段修改为<code>theme: next</code>从而应用布置好的NexT主题<br>同样可以找到如图字段：<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/site.png" alt="site"><br>将language字段修改为<code>language: zh-Hans</code>即可应用主题为中文版，在其他字段中可以直接修改个人博客的标题、子标题、描述等信息。</p></li></ol><ol><li><p><strong>配置主题配置</strong><br>打开主题配置中的<code>_config.yml</code>可以看到主题配置内容，此步骤只强调几个终点配置。</p><ul><li><strong>配置菜单</strong><br>找到如图menu配置，修改menu中的字段对应博客主页菜单的变化<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/menu.png" alt="menu"></li><li><p><strong>配置NexT主题</strong><br>找到如图Schemes配置，修改scheme字段可以修改NexT子主题<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/scheme.png" alt="scheme"></p></li><li><p><strong>配置博客头像</strong><br>在配置文件任意独立行输入<code>avatar: /images/avatar.png</code>，之后在本地博客目录下<code>source</code>文件夹下新建文件夹<code>images</code>，选择自己喜欢的博客头像改为<code>avatar.png</code>同名文件放置在该目录下即可。</p></li><li><p><strong>配置favicon图标</strong><br>所谓favicon如图，可以想<code>images</code>文件夹下添加名为<code>favicon.ico</code>的图标文件修改。</p></li></ul></li></ol><h3 id="连接本地Hexo和gitpages"><a href="#连接本地Hexo和gitpages" class="headerlink" title="连接本地Hexo和gitpages"></a>连接本地Hexo和gitpages</h3><ol><li><p><strong>配置与Github Pages关联</strong><br>打开本地配置的<code>_config.yml</code>，找到如图deploy字段：<br><img src="/2017/10/25/%E4%BD%BF%E7%94%A8Hexo%E5%92%8CGithub%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/deploy.png" alt="deploy">并如图配置,其中红框为你的github帐号，白框为github密码，灰框(最右)为你建立的仓库地址。</p></li><li><p><strong>部署github托管</strong><br>很简单，本地博客目录打开gitbash，输入<code>hexo d</code>即完成在线部署。<br><strong>至此，你的个人博客线上部署已经完成！</strong></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>next-theme</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
